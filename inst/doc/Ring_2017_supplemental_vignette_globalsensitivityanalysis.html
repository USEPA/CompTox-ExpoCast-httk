<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Caroline Ring" />

<meta name="date" content="2018-04-05" />

<title>Ring et al. 2017 Global sensitivity analysis</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">Ring et al. 2017 Global sensitivity analysis</h1>
<h4 class="author"><em>Caroline Ring</em></h4>
<h4 class="date"><em>2018-04-05</em></h4>



<p>This vignette includes the code to perform the global sensitivity analysis described in the HTTK-Pop paper.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(httk)
<span class="kw">library</span>(data.table)
<span class="kw">library</span>(parallel)</code></pre></div>
<p>Basically, the idea of the Sobol method is to apportion variance: to estimate how much of the variance in a model’s output is contributed by variance in each of the model parameters. The fraction of output variance attributable to each parameter is called the sensitivity index for that parameter.</p>
<p>The sensitivity indexes can be estimated using the following method. Generate two parameter matrices, independently of one another. Call them Matrix A and Matrix B. Evaluate the model using A and B, to get two vectors of output, fA and fB. Then, swap one column at a time between A and B. If you swap column i, the resulting matrices can be called ABi (for matrix A, with column i from matrix B) and BAi (for matrix B, with column i from matrix A). Evaluate the model for the column-swapped matrices to get another two vectors of output, fABi and fBAi. Then first-order and total sensitivity indices can be estimated from the correlation coefficients between output vectors (Glen &amp; Isaacs 2012).</p>
<p>With HTTK-Pop, this means we need to generate two virtual populations with the same specifications. For each chemical, we then need to add <code>Funbound.plasma</code> and <code>Clint</code> columns to each population matrix, and convert it into a matrix of HTTK model parameters. That will give matrices A and B, for each chemical. Then, we need to swap columns, evaluate the model, and compute the sensitivity indices from the correlations.</p>
<p>Let’s get started. First, let’s generate the two virtual populations using HTTK-Pop. These are strictly physiological parameters – no chemical dependence – so we can just do this once and re-use the two virtual populations for each chemical.</p>
<p>We’ll generate virtual populations for each of the ten ExpoCast subpopulations of interest, to see if and how global sensitivity changes by subpopulation. In fact, we’ve already generated one set of virtual populations in the “Generating subpopulations” vignette. Let’s just re-use those as the first virtual population, and repeat the same procedure to generate a second virtual population, for each subpopulation.</p>
<p>We’ll use the same seed as before (based on my name), but increment it by 1, so that the two virtual populations are not identical.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">seed.int &lt;-<span class="st"> </span>TeachingDemos::<span class="kw">char2seed</span>(<span class="st">'Caroline Ring'</span>, <span class="dt">set=</span><span class="ot">FALSE</span>)+<span class="dv">1</span></code></pre></div>
<p>We set up the subpopulation specifications in the same way as before.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">nsamp&lt;-<span class="dv">1000</span>
ExpoCast.group&lt;-<span class="kw">list</span>(<span class="st">&quot;Total&quot;</span>,
                     <span class="st">&quot;Age.6.11&quot;</span>,
                     <span class="st">&quot;Age.12.19&quot;</span>,
                     <span class="st">&quot;Age.20.65&quot;</span>,
                     <span class="st">&quot;Age.GT65&quot;</span>,
                     <span class="st">&quot;BMIgt30&quot;</span>,
                     <span class="st">&quot;BMIle30&quot;</span>,
                     <span class="st">&quot;Females&quot;</span>,
                     <span class="st">&quot;Males&quot;</span>,
                     <span class="st">&quot;ReproAgeFemale&quot;</span>,
                     <span class="st">&quot;Age.20.50.nonobese&quot;</span>)

gendernum &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">rep</span>(<span class="kw">list</span>(<span class="ot">NULL</span>),<span class="dv">7</span>), 
               <span class="kw">list</span>(<span class="kw">list</span>(<span class="dt">Male=</span><span class="dv">0</span>, <span class="dt">Female=</span><span class="dv">1000</span>)), 
               <span class="kw">list</span>(<span class="kw">list</span>(<span class="dt">Male=</span><span class="dv">1000</span>, <span class="dt">Female=</span><span class="dv">0</span>)), 
               <span class="kw">list</span>(<span class="kw">list</span>(<span class="dt">Male=</span><span class="dv">0</span>, <span class="dt">Female=</span><span class="dv">1000</span>)), 
               <span class="kw">list</span>(<span class="ot">NULL</span>))

agelim&lt;-<span class="kw">c</span>(<span class="kw">list</span>(<span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">79</span>),
               <span class="kw">c</span>(<span class="dv">6</span>,<span class="dv">11</span>),
               <span class="kw">c</span>(<span class="dv">12</span>,<span class="dv">19</span>),
               <span class="kw">c</span>(<span class="dv">20</span>,<span class="dv">65</span>),
               <span class="kw">c</span>(<span class="dv">66</span>,<span class="dv">79</span>)),
          <span class="kw">rep</span>(<span class="kw">list</span>(<span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">79</span>)),<span class="dv">4</span>),
          <span class="kw">list</span>(<span class="kw">c</span>(<span class="dv">16</span>,<span class="dv">49</span>)),
          <span class="kw">list</span>(<span class="kw">c</span>(<span class="dv">20</span>,<span class="dv">50</span>)))

bmi_category &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">rep</span>(<span class="kw">list</span>(<span class="kw">c</span>(<span class="st">'Underweight'</span>, 
                             <span class="st">'Normal'</span>,
                             <span class="st">'Overweight'</span>,
                             <span class="st">'Obese'</span>)),
                      <span class="dv">5</span>),
                  <span class="kw">list</span>(<span class="st">'Obese'</span>,
                       <span class="kw">c</span>(<span class="st">'Underweight'</span>,<span class="st">'Normal'</span>, <span class="st">'Overweight'</span>)),
                  <span class="kw">rep</span>(<span class="kw">list</span>(<span class="kw">c</span>(<span class="st">'Underweight'</span>, 
                             <span class="st">'Normal'</span>,
                             <span class="st">'Overweight'</span>,
                             <span class="st">'Obese'</span>)),
                      <span class="dv">3</span>),
                  <span class="kw">list</span>(<span class="kw">c</span>(<span class="st">'Underweight'</span>, <span class="st">'Normal'</span>, <span class="st">'Overweight'</span>)))</code></pre></div>
<p>Then we just evaluate another set of virtual populations, using the direct resampling method.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">tmpfun &lt;-<span class="st"> </span>function(gendernum, agelim, bmi_category, ExpoCast_grp,
                   nsamp, method){
  result &lt;-<span class="st"> </span><span class="kw">tryCatch</span>({
    pops &lt;-<span class="st"> </span>httk::<span class="kw">httkpop_generate</span>(
      <span class="dt">method=</span>method,
      <span class="dt">nsamp=</span>nsamp,
      <span class="dt">gendernum =</span> gendernum,
      <span class="dt">agelim_years =</span> agelim,
      <span class="dt">weight_category =</span> bmi_category)
    
    filepart &lt;-<span class="st"> </span>switch(method,
                       <span class="st">'virtual individuals'</span> =<span class="st"> 'vi'</span>,
                       <span class="st">'direct resampling'</span> =<span class="st"> 'dr'</span>)
    <span class="kw">saveRDS</span>(<span class="dt">object=</span>pops,
            <span class="dt">file=</span><span class="kw">paste0</span>(<span class="st">'data/httkpop_'</span>,
                        filepart,
                        <span class="st">'_'</span>,
                        ExpoCast_grp,
                        <span class="st">'2.Rdata'</span>)) <span class="co">#Note we've added a 2 to the file name!</span>
    <span class="kw">return</span>(<span class="dv">0</span>)
    }, <span class="dt">error =</span> function(err){
      <span class="kw">print</span>(<span class="kw">paste</span>(<span class="st">'Error occurred:'</span>, err))
      <span class="kw">return</span>(<span class="dv">1</span>)
      })
  }


cluster &lt;-<span class="st"> </span>parallel::<span class="kw">makeCluster</span>(<span class="dv">40</span>, 
                                 <span class="dt">outfile=</span><span class="st">'subpopulations_parallel_out2.txt'</span>)

evalout &lt;-<span class="st"> </span>parallel::<span class="kw">clusterEvalQ</span>(<span class="dt">cl=</span>cluster,
                                  {<span class="kw">library</span>(data.table)
                                   <span class="kw">library</span>(httk)})
parallel::<span class="kw">clusterExport</span>(<span class="dt">cl =</span> cluster,
                        <span class="dt">varlist =</span> <span class="st">'tmpfun'</span>)
<span class="co">#Set seeds on all workers for reproducibility</span>
parallel::<span class="kw">clusterSetRNGStream</span>(cluster, 
                              seed.int)
out_dr &lt;-<span class="st"> </span>parallel::<span class="kw">clusterMap</span>(<span class="dt">cl=</span>cluster,
                               <span class="dt">fun =</span> tmpfun,
                               <span class="dt">gendernum=</span>gendernum,
                               <span class="dt">agelim=</span>agelim,
                               <span class="dt">bmi_category=</span>bmi_category,
                               <span class="dt">ExpoCast_grp =</span> ExpoCast.group,
                               <span class="dt">MoreArgs =</span> <span class="kw">list</span>(<span class="dt">nsamp =</span> nsamp,
                                               <span class="dt">method =</span> <span class="st">'direct resampling'</span>)
                               )
parallel::<span class="kw">stopCluster</span>(cluster)</code></pre></div>
<p>Great. Now, let’s think of the procedure as looping first over the ten subpopulations of interest, and then over the chemicals in the HTTK data set. So first, let’s think about what we need to do for each chemical, given a subpopulation.</p>
<p>We need to draw <code>Funbound.plasma</code> and <code>Clint</code> samples for the two virtual populations and convert into HTTK parameter matrices. That will give us matrix A and matrix B. Then, we need to evaluate yA and yB. Then, we need to loop over the HTTK model parameters – the columns of A and B – and swap one column at a time between A and B. For parameter i, we then need to evaluate yABi and yBAi. Then, we need to compute the correlations, and from them the sensitivity indices for parameter i.</p>
<p>So we can write some pseudocode like this:</p>
<ul>
<li>for subpopulation subpop</li>
<li>load previously-generated virtual population 1</li>
<li>generate virtual population 2</li>
<li>for chemical chem</li>
<li>draw Funbound.plasma and Clint for virtual population 1</li>
<li>draw Funbound.plasma and Clint for virtual population 2</li>
<li>convert virtual population 1 into HTTK parameter matrix A</li>
<li>convert virtual population 2 into HTTK parameter matrix B</li>
<li>evaluate HTTK model for A and B, yielding yA and yB</li>
<li>for HTTK parameter i{</li>
<li>swap column i between A and B, forming ABi and BAi</li>
<li>evaluate HTTK model for ABi and BAi, yielding yABi and yBAi</li>
<li>compute correlations among yA, yB, yABi, yBAi</li>
<li>compute sensitivity indexes for parameter i</li>
<li>end loop over HTTK parameters</li>
<li>end loop over chemicals</li>
<li>end loop over subpopulations</li>
</ul>
<div id="for-each-parameter" class="section level1">
<h1>For each parameter</h1>
<p>Let’s start with the innermost loop: what we want to do for each parameter i.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">doforeachparam &lt;-<span class="st"> </span>function(i,
                           indiv.A,
                           indiv.B,
                           this.chemcas,
                           model,
                           <span class="dt">species=</span><span class="st">'Human'</span>,
                           css.method,
                           f.A, <span class="co">#already evaluated model for A</span>
                           f.B, <span class="co">#already evaluated model for B</span>
                           g0, <span class="co">#normalized f.A</span>
                           g0prime, <span class="co">#normalized f.B</span>
                           p0){ <span class="co">#spurious correlation betweenf.A and f.B</span>
  
  <span class="co">#make copies so as not to change these data.tables outside the function</span>
  indiv.A &lt;-<span class="st"> </span><span class="kw">copy</span>(indiv.A)
  indiv.B &lt;-<span class="st"> </span><span class="kw">copy</span>(indiv.B)
  
  <span class="co">#First, let's swap column i.</span>
  indiv.ABi &lt;-<span class="st"> </span><span class="kw">copy</span>(indiv.A)
  indiv.ABi[, (i):<span class="er">=</span><span class="st"> </span>indiv.B[, i, with=<span class="ot">FALSE</span>]]
  indiv.BAi &lt;-<span class="st"> </span><span class="kw">copy</span>(indiv.B)
  indiv.BAi[, (i):<span class="er">=</span>indiv.A[, i, with=<span class="ot">FALSE</span>]]
  
  <span class="co">#Convert to HTTK parameters for matrix ABi and matrix BAi</span>
  indiv.ABi.httk &lt;-<span class="st"> </span>httk::<span class="kw">convert_httk</span>(<span class="dt">indiv.model.bio =</span> indiv.ABi,
                                          <span class="dt">model =</span> model,
                                          <span class="dt">this.chem =</span> this.chemcas)
  indiv.BAi.httk &lt;-<span class="st"> </span>httk::<span class="kw">convert_httk</span>(<span class="dt">indiv.model.bio =</span> indiv.BAi,
                                          <span class="dt">model =</span> model,
                                          <span class="dt">this.chem =</span> this.chemcas)
  
  <span class="co">#If model is 3compartmentss, convert Funbound.plasma to Funbound.blood</span>
  if (model==<span class="st">&quot;3compartmentss&quot;</span>){
    <span class="co">#First, get the default parameters used for the Schmitt method of estimating</span>
    <span class="co">#partition coefficients.</span>
    pschmitt &lt;-<span class="st"> </span>httk::<span class="kw">parameterize_schmitt</span>(<span class="dt">chem.cas=</span>this.chemcas,
                                           <span class="dt">species=</span><span class="st">'Human'</span>)
    convert_Fup &lt;-<span class="st"> </span>function(DT.bio, DT.httk, pschmitt, this.chemcas){
      DT.bio &lt;-<span class="st"> </span><span class="kw">copy</span>(DT.bio)
      DT.httk &lt;-<span class="st"> </span><span class="kw">copy</span>(DT.httk)
    <span class="co">#next, replace the single default value for Funbound.plasma with the vector</span>
    <span class="co">#of Funbound.plasma values from the virtual population data.table.</span>
    pschmitt$Funbound.plasma&lt;-DT.httk[, Funbound.plasma]
    <span class="co">#Now, predict the partitioning coefficients using Schmitt's method. The</span>
    <span class="co">#result will be a list of numerical vectors, one vector for each</span>
    <span class="co">#tissue-to-plasma partitioning coefficient, and one element of each vector</span>
    <span class="co">#for each individual. The list element names specify which partition</span>
    <span class="co">#coefficient it is, e.g. Kliver2plasma, Kgut2plasma, etc.</span>
    PCs &lt;-<span class="st"> </span>httk::<span class="kw">predict_partitioning_schmitt</span>(<span class="dt">parameters=</span>pschmitt,
                                              <span class="dt">chem.cas=</span>this.chemcas,
                                              <span class="dt">species=</span><span class="st">'Human'</span>)
    <span class="co">#Compute predicted Rblood2plasma (amount in blood/amount in plasma)</span>
    Rb2p &lt;-<span class="st"> </span><span class="dv">1</span> -<span class="st"> </span>DT.bio$hematocrit +<span class="st"> </span>DT.bio$hematocrit *<span class="st"> </span>
<span class="st">      </span>PCs[[<span class="st">&quot;Krbc2pu&quot;</span>]] *<span class="st"> </span>
<span class="st">      </span>DT.httk$Funbound.plasma
    
  Funbound.blood &lt;-<span class="st"> </span>DT.httk$Funbound.plasma/Rb2p
  <span class="kw">return</span>(<span class="kw">list</span>(<span class="dt">Rb2p=</span>Rb2p,
              <span class="dt">Funbound.blood=</span>Funbound.blood))
  }
  
  Fconvert.ABi &lt;-<span class="st"> </span><span class="kw">convert_Fup</span>(<span class="dt">DT.bio=</span>indiv.ABi,
                                                <span class="dt">DT.httk=</span>indiv.ABi.httk,
                                                <span class="dt">pschmitt=</span>pschmitt,
                                                <span class="dt">this.chemcas=</span>this.chemcas)
  
  Fconvert.BAi &lt;-<span class="st"> </span><span class="kw">convert_Fup</span>(<span class="dt">DT.bio=</span>indiv.BAi,
                                                <span class="dt">DT.httk=</span>indiv.BAi.httk,
                                                <span class="dt">pschmitt=</span>pschmitt,
                                                <span class="dt">this.chemcas=</span>this.chemcas)
  
  indiv.ABi.httk[, Funbound.plasma:<span class="er">=</span>Fconvert.ABi$Funbound.blood]
  indiv.BAi.httk[, Funbound.plasma:<span class="er">=</span>Fconvert.BAi$Funbound.blood]
  }
  <span class="co">#Next, let's evaluate the model.</span>
  if (<span class="kw">tolower</span>(css.method)==<span class="st">'analytic'</span>) {
    f.ABi &lt;-<span class="st"> </span>httk::<span class="kw">calc_analytic_css</span>(<span class="dt">chem.cas=</span>this.chemcas,
                                     <span class="dt">parameters=</span>indiv.ABi.httk,
                                     <span class="dt">daily.dose=</span><span class="dv">1</span>, 
                                     <span class="dt">output.units=</span><span class="st">&quot;uM&quot;</span>,
                                     <span class="dt">model=</span>model,
                                     <span class="dt">species=</span>species,
                                     <span class="dt">suppress.messages=</span><span class="ot">TRUE</span>,
                                     <span class="dt">recalc.blood2plasma=</span><span class="ot">TRUE</span>)
    f.BAi &lt;-<span class="st"> </span>httk::<span class="kw">calc_analytic_css</span>(<span class="dt">chem.cas=</span>this.chemcas,
                                     <span class="dt">parameters=</span>indiv.BAi.httk,
                                     <span class="dt">daily.dose=</span><span class="dv">1</span>, 
                                     <span class="dt">output.units=</span><span class="st">&quot;uM&quot;</span>,
                                     <span class="dt">model=</span>model,
                                     <span class="dt">species=</span>species,
                                     <span class="dt">suppress.messages=</span><span class="ot">TRUE</span>,
                                     <span class="dt">recalc.blood2plasma=</span><span class="ot">TRUE</span>)
    
    if (model==<span class="st">&quot;3compartmentss&quot;</span>){
      f.ABi &lt;-<span class="st"> </span>f.ABi/Fconvert.ABi$Rb2p
      f.BAi &lt;-<span class="st"> </span>f.BAi/Fconvert.BAi$Rb2p
    }
    }
  else if (<span class="kw">tolower</span>(css.method)==<span class="st">'full'</span>){
    f.ABi &lt;-<span class="st"> </span><span class="kw">apply</span>(<span class="dt">X=</span>indiv.ABi.httk, 
                   <span class="dt">MARGIN=</span><span class="dv">1</span>,
                   <span class="dt">FUN=</span>function(x) httk::<span class="kw">calc_css</span>(<span class="dt">chem.cas=</span>this.chemcas,
                                                  <span class="dt">parameters=</span><span class="kw">as.list</span>(x),
                                                  <span class="dt">daily.dose=</span><span class="dv">1</span>, 
                                                  <span class="dt">output.units=</span><span class="st">&quot;uM&quot;</span>,
                                                  <span class="dt">model=</span>model,
                                                  <span class="dt">species=</span>species,
                                                  <span class="dt">suppress.messages=</span><span class="ot">TRUE</span>,
                                                  <span class="dt">f.change=</span><span class="fl">1e-5</span>)[[<span class="st">'avg'</span>]])
    f.BAi &lt;-<span class="st"> </span><span class="kw">apply</span>(<span class="dt">X=</span>indiv.BAi.httk, 
                   <span class="dt">MARGIN=</span><span class="dv">1</span>,
                   <span class="dt">FUN=</span>function(x) httk::<span class="kw">calc_css</span>(<span class="dt">chem.cas=</span>this.chemcas,
                                                  <span class="dt">parameters=</span><span class="kw">as.list</span>(x),
                                                  <span class="dt">daily.dose=</span><span class="dv">1</span>, 
                                                  <span class="dt">output.units=</span><span class="st">&quot;uM&quot;</span>,
                                                  <span class="dt">model=</span>model,
                                                  <span class="dt">species=</span>species,
                                                  <span class="dt">suppress.messages=</span><span class="ot">TRUE</span>,
                                                  <span class="dt">f.change=</span><span class="fl">1e-5</span>)[[<span class="st">'avg'</span>]])
    }
  
  <span class="co">#Finally, let's estimate the correlations and the sensitivity indexes. This code uses the same notation as Glen and Isaacs, so you can follow along from their paper.</span>
  gj &lt;-<span class="st"> </span>(f.ABi-<span class="kw">mean</span>(f.ABi))/<span class="kw">sqrt</span>(<span class="kw">var</span>(f.ABi) *<span class="st"> </span>(<span class="kw">length</span>(f.ABi)-<span class="dv">1</span>) /<span class="st"> </span><span class="kw">length</span>(f.ABi))
  gjprime&lt;-(f.BAi-<span class="kw">mean</span>(f.BAi))/<span class="kw">sqrt</span>(<span class="kw">var</span>(f.BAi) *<span class="st"> </span>(<span class="kw">length</span>(f.BAi)-<span class="dv">1</span>) /<span class="st"> </span><span class="kw">length</span>(f.BAi))
  
  csj &lt;-<span class="st"> </span><span class="kw">mean</span>(g0prime*gj)
  csminusj &lt;-<span class="st"> </span><span class="kw">mean</span>(g0*gj)
  cdj &lt;-<span class="st"> </span><span class="kw">sum</span>(g0prime*gj +<span class="st"> </span>g0*gjprime)/(<span class="dv">2</span>*<span class="kw">length</span>(g0))
  cdminusj &lt;-<span class="st"> </span><span class="kw">sum</span>(g0*gj +<span class="st"> </span>g0prime*gjprime)/(<span class="dv">2</span>*<span class="kw">length</span>(g0))
  pj &lt;-<span class="st"> </span><span class="kw">sum</span>(g0*g0prime +<span class="st"> </span>gj*gjprime)/(<span class="dv">2</span>*<span class="kw">length</span>(g0))
  caj &lt;-<span class="st"> </span>(cdj-pj*cdminusj)/(<span class="dv">1</span>-pj^<span class="dv">2</span>)
  caminusj &lt;-<span class="st"> </span>(cdminusj -<span class="st"> </span>pj*cdj)/(<span class="dv">1</span>-pj^<span class="dv">2</span>)
  Si &lt;-<span class="st"> </span>cdj -<span class="st"> </span>pj*(caminusj)/(<span class="dv">1</span>-caj*caminusj)
  Ti &lt;-<span class="st"> </span><span class="dv">1</span> -<span class="st"> </span>cdminusj +<span class="st"> </span>pj*caj/(<span class="dv">1</span>-caj*caminusj)
  <span class="kw">return</span>(<span class="kw">list</span>(<span class="dt">Ti=</span>Ti,
              <span class="dt">Si=</span>Si,
              <span class="dt">p0=</span>p0,
              <span class="dt">pj=</span>pj,
              <span class="dt">csj=</span>csj,
              <span class="dt">csminusj=</span>csminusj,
              <span class="dt">cdj=</span>cdj,
              <span class="dt">cdminusj=</span>cdminusj,
              <span class="dt">caj=</span>caj,
              <span class="dt">caminusj=</span>caminusj))
  }</code></pre></div>
</div>
<div id="for-each-chemical" class="section level1">
<h1>For each chemical</h1>
<p>Great. Now take one step out, and define a function for what we need to do for each chemical.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">doforeachchem &lt;-<span class="st"> </span>function(this.chemcas, <span class="co">#CAS for one chemical </span>
                          model, <span class="co">#HTTK model to use</span>
                          <span class="dt">species=</span><span class="st">'Human'</span>, <span class="co">#Species for HTTK</span>
                          nsamp, <span class="co">#Number of people in virtual population</span>
                          css.method, <span class="co">#'analytic' or 'full'</span>
                          <span class="dt">sigma.factor=</span><span class="fl">0.3</span>, <span class="co">#coefficient of variation</span>
                          indiv.model.bio1, <span class="co">#output of httkbio()</span>
                          indiv.model.bio2, <span class="co">#output of httkbio()</span>
                          ExpoCast.group, <span class="co">#subpopulation of interest</span>
                          poormetab, <span class="co">#TRUE or FALSE</span>
                          fup.censor){ <span class="co">#TRUE or FALSE</span>
                           
  <span class="co">#To avoid making changes outside the function</span>
  indiv.model.bio1 &lt;-<span class="st"> </span><span class="kw">copy</span>(indiv.model.bio1)
  indiv.model.bio2 &lt;-<span class="st"> </span><span class="kw">copy</span>(indiv.model.bio2)
  
  <span class="co">#First draw Funbound.plasma and Clint</span>
  indiv.A &lt;-<span class="st"> </span><span class="kw">cbind</span>(indiv.model.bio1,
                   httk::<span class="kw">draw_fup_clint</span>(<span class="dt">this.chem=</span>this.chemcas,
                                     <span class="dt">nsamp=</span><span class="kw">nrow</span>(indiv.model.bio1),
                                     <span class="dt">sigma.factor=</span>sigma.factor,
                                     <span class="dt">poormetab=</span>poormetab,
                                     <span class="dt">fup.censor=</span>fup.censor))
  indiv.B &lt;-<span class="st"> </span><span class="kw">cbind</span>(indiv.model.bio2, 
                   httk::<span class="kw">draw_fup_clint</span>(<span class="dt">this.chem=</span>this.chemcas,
                                     <span class="dt">nsamp=</span><span class="kw">nrow</span>(indiv.model.bio2),
                                     <span class="dt">sigma.factor=</span>sigma.factor,
                                     <span class="dt">poormetab=</span>poormetab,
                                     <span class="dt">fup.censor=</span>fup.censor))
  <span class="co">#Convert to HTTK parameters for matrix A and matrix B</span>
  indiv.A.httk &lt;-<span class="st"> </span>httk::<span class="kw">convert_httk</span>(<span class="dt">indiv.model.bio =</span> indiv.A,
                                        <span class="dt">model =</span> model,
                                        <span class="dt">this.chem =</span> this.chemcas)
  indiv.B.httk &lt;-<span class="st"> </span>httk::<span class="kw">convert_httk</span>(<span class="dt">indiv.model.bio =</span> indiv.B,
                                        <span class="dt">model =</span> model,
                                        <span class="dt">this.chem =</span> this.chemcas)
  
  <span class="co">#If model is 3compartmentss, convert Funbound.plasma to Funbound.blood</span>
  if (model==<span class="st">&quot;3compartmentss&quot;</span>){
    <span class="co">#First, get the default parameters used for the Schmitt method of estimating</span>
    <span class="co">#partition coefficients.</span>
    pschmitt &lt;-<span class="st"> </span>httk::<span class="kw">parameterize_schmitt</span>(<span class="dt">chem.cas=</span>this.chemcas,
                                           <span class="dt">species=</span><span class="st">'Human'</span>)
    convert_Fup &lt;-<span class="st"> </span>function(DT.bio, DT.httk, pschmitt, this.chemcas){
      DT.bio &lt;-<span class="st"> </span><span class="kw">copy</span>(DT.bio)
      DT.httk &lt;-<span class="st"> </span><span class="kw">copy</span>(DT.httk)
    <span class="co">#next, replace the single default value for Funbound.plasma with the vector</span>
    <span class="co">#of Funbound.plasma values from the virtual population data.table.</span>
    pschmitt$Funbound.plasma&lt;-DT.httk[, Funbound.plasma]
    <span class="co">#Now, predict the partitioning coefficients using Schmitt's method. The</span>
    <span class="co">#result will be a list of numerical vectors, one vector for each</span>
    <span class="co">#tissue-to-plasma partitioning coefficient, and one element of each vector</span>
    <span class="co">#for each individual. The list element names specify which partition</span>
    <span class="co">#coefficient it is, e.g. Kliver2plasma, Kgut2plasma, etc.</span>
    PCs &lt;-<span class="st"> </span>httk::<span class="kw">predict_partitioning_schmitt</span>(<span class="dt">parameters=</span>pschmitt,
                                              <span class="dt">chem.cas=</span>this.chemcas,
                                              <span class="dt">species=</span><span class="st">'Human'</span>)
    Rb2p &lt;-<span class="st"> </span><span class="dv">1</span> -<span class="st"> </span>DT.bio$hematocrit +<span class="st"> </span>DT.bio$hematocrit *<span class="st"> </span>
<span class="st">      </span>PCs[[<span class="st">&quot;Krbc2pu&quot;</span>]] *<span class="st"> </span>
<span class="st">      </span>DT.httk$Funbound.plasma
    
  Funbound.blood &lt;-<span class="st"> </span>DT.httk$Funbound.plasma/Rb2p
  <span class="kw">return</span>(<span class="kw">list</span>(<span class="dt">Rb2p=</span>Rb2p,
              <span class="dt">Funbound.blood=</span>Funbound.blood))
  }
  
  Fconvert.A &lt;-<span class="st"> </span><span class="kw">convert_Fup</span>(<span class="dt">DT.bio=</span>indiv.A,
                                                <span class="dt">DT.httk=</span>indiv.A.httk,
                                                <span class="dt">pschmitt=</span>pschmitt,
                                                <span class="dt">this.chemcas=</span>this.chemcas)
  
  Fconvert.B &lt;-<span class="st"> </span><span class="kw">convert_Fup</span>(<span class="dt">DT.bio=</span>indiv.B,
                                                <span class="dt">DT.httk=</span>indiv.B.httk,
                                                <span class="dt">pschmitt=</span>pschmitt,
                                                <span class="dt">this.chemcas=</span>this.chemcas)
  
  indiv.A.httk[, Funbound.plasma:<span class="er">=</span>Fconvert.A$Funbound.blood]
  indiv.B.httk[, Funbound.plasma:<span class="er">=</span>Fconvert.B$Funbound.blood]
  }
  <span class="co">#Evaluate model</span>
  if (<span class="kw">tolower</span>(css.method)==<span class="st">'analytic'</span>) {
    f.A &lt;-<span class="st"> </span>httk::<span class="kw">calc_analytic_css</span>(<span class="dt">chem.cas=</span>this.chemcas,
                                   <span class="dt">parameters=</span>indiv.A.httk,
                                   <span class="dt">daily.dose=</span><span class="dv">1</span>, 
                                   <span class="dt">output.units=</span><span class="st">&quot;uM&quot;</span>,
                                   <span class="dt">model=</span>model,
                                   <span class="dt">species=</span>species,
                                   <span class="dt">suppress.messages=</span><span class="ot">TRUE</span>,
                                   <span class="dt">recalc.blood2plasma=</span><span class="ot">TRUE</span>)
    f.B &lt;-<span class="st"> </span>httk::<span class="kw">calc_analytic_css</span>(<span class="dt">chem.cas=</span>this.chemcas,
                                   <span class="dt">parameters=</span>indiv.B.httk,
                                   <span class="dt">daily.dose=</span><span class="dv">1</span>, 
                                   <span class="dt">output.units=</span><span class="st">&quot;uM&quot;</span>,
                                   <span class="dt">model=</span>model,
                                   <span class="dt">species=</span>species,
                                   <span class="dt">suppress.messages=</span><span class="ot">TRUE</span>,
                                   <span class="dt">recalc.blood2plasma=</span><span class="ot">TRUE</span>)
    
    if (model==<span class="st">&quot;3compartmentss&quot;</span>){
      f.A &lt;-<span class="st"> </span>f.A/Fconvert.A$Rb2p
      f.B &lt;-<span class="st"> </span>f.B/Fconvert.B$Rb2p
    }
    }
  else if (<span class="kw">tolower</span>(css.method)==<span class="st">'full'</span>){
    f.A &lt;-<span class="st"> </span><span class="kw">apply</span>(<span class="dt">X=</span>indiv.A.httk, 
                 <span class="dt">MARGIN=</span><span class="dv">1</span>,
                 <span class="dt">FUN=</span>function(x) httk::<span class="kw">calc_css</span>(<span class="dt">chem.cas=</span>this.chemcas,
                                                <span class="dt">parameters=</span><span class="kw">as.list</span>(x),
                                                <span class="dt">daily.dose=</span><span class="dv">1</span>, 
                                                <span class="dt">output.units=</span><span class="st">&quot;uM&quot;</span>,
                                                <span class="dt">model=</span>model,
                                                <span class="dt">species=</span>species,
                                                <span class="dt">suppress.messages=</span><span class="ot">TRUE</span>,
                                                <span class="dt">f.change=</span><span class="fl">1e-5</span>)[[<span class="st">'avg'</span>]])
    f.B &lt;-<span class="st"> </span><span class="kw">apply</span>(<span class="dt">X=</span>indiv.B.httk, 
                 <span class="dt">MARGIN=</span><span class="dv">1</span>,
                 <span class="dt">FUN=</span>function(x) httk::<span class="kw">calc_css</span>(<span class="dt">chem.cas=</span>this.chemcas,
                                                <span class="dt">parameters=</span><span class="kw">as.list</span>(x),
                                                <span class="dt">daily.dose=</span><span class="dv">1</span>, 
                                                <span class="dt">output.units=</span><span class="st">&quot;uM&quot;</span>,
                                                <span class="dt">model=</span>model,
                                                <span class="dt">species=</span>species,
                                                <span class="dt">suppress.messages=</span><span class="ot">TRUE</span>,
                                                <span class="dt">f.change=</span><span class="fl">1e-5</span>)[[<span class="st">'avg'</span>]])
    }
  <span class="co">#Compute normalized data (number of standard deviations from the mean)</span>
  g0&lt;-(f.A-<span class="kw">mean</span>(f.A))/<span class="kw">sqrt</span>(<span class="kw">var</span>(f.A) *<span class="st"> </span>(<span class="kw">length</span>(f.A)-<span class="dv">1</span>) /<span class="st"> </span><span class="kw">length</span>(f.A))
  g0prime &lt;-<span class="st"> </span>(f.B-<span class="kw">mean</span>(f.B))/<span class="kw">sqrt</span>(<span class="kw">var</span>(f.B) *<span class="st"> </span>(<span class="kw">length</span>(f.B)-<span class="dv">1</span>) /<span class="st"> </span><span class="kw">length</span>(f.B))
  
  <span class="co">#Compute spurious correlation term between f.A and f.B</span>
  p0 &lt;-<span class="st"> </span><span class="kw">mean</span>(g0*g0prime)
  
  <span class="co">#Next, define the list of HTTK parameters that constitute the physiological parameters for this model.</span>
  <span class="co">#Strictly speaking this should be all of the columns in indiv.model.bio1, except for liver.density, which is a fixed value.</span>
  phys.par &lt;-<span class="st"> </span><span class="kw">names</span>(indiv.model.bio1)[<span class="kw">names</span>(indiv.model.bio1)!=
<span class="st">                                        'liver.density'</span>]
  <span class="co">#Add Funbound.plasma</span>
  parlist &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="st">'Funbound.plasma'</span>,
                  <span class="st">'Clint'</span>,
                  phys.par)
  <span class="co">#Note: this is a list with three members! </span>
  <span class="co">#Sensitivity is calculated to the *group* of physiological parameters *as a whole*, not to each one individually.</span>
  
  <span class="co">#If Clint is fixed at zero,</span>
  <span class="co">#don't test sensitivity to it</span>
  if (<span class="kw">all</span>(indiv.A[, Clint]==<span class="dv">0</span>)){
    parlist &lt;-<span class="st"> </span>parlist[parlist!=<span class="st">'Clint'</span>]
    }
  
  <span class="co">#Now loop over parameters (and groups thereof)</span>
  eff.list &lt;-<span class="st"> </span><span class="kw">lapply</span>(parlist,
                     doforeachparam,
                     <span class="dt">indiv.A=</span>indiv.A,
                     <span class="dt">indiv.B=</span>indiv.B,
                     <span class="dt">this.chemcas=</span>this.chemcas,
                     <span class="dt">model=</span>model,
                     <span class="dt">species=</span>species,
                     <span class="dt">css.method=</span>css.method,
                     <span class="dt">f.A=</span>f.A,
                     <span class="dt">f.B=</span>f.B,
                     <span class="dt">g0=</span>g0,
                     <span class="dt">g0prime=</span>g0prime,
                     <span class="dt">p0=</span>p0)
  
  parnames &lt;-<span class="st"> </span>parlist
  <span class="co">#Name the sensitivity indexes by their parameters</span>
  <span class="co">#For the group of physiological parameters, just name it &quot;phys.par&quot;</span>
  parnames[<span class="kw">sapply</span>(parnames, function(x) <span class="kw">length</span>(x)&gt;<span class="dv">1</span>)] &lt;-<span class="st"> 'phys.par'</span>
  <span class="kw">names</span>(eff.list) &lt;-<span class="st"> </span>parnames
  
  <span class="co">#If Clint was zero, then sensitivity to it wasn't calculated.</span>
  <span class="co">#Set all the sensitivity quantities to NA to indicate this.</span>
  if (<span class="kw">all</span>(indiv.A[, Clint]==<span class="dv">0</span>)){
    eff.list &lt;-<span class="st"> </span><span class="kw">c</span>(eff.list,
                  <span class="kw">list</span>(<span class="dt">Clint=</span><span class="kw">list</span>(<span class="dt">Ti=</span><span class="ot">NA</span>,
                                  <span class="dt">Si=</span><span class="ot">NA</span>,
                                  <span class="dt">p0=</span><span class="ot">NA</span>,
                                  <span class="dt">pj=</span><span class="ot">NA</span>,
                                  <span class="dt">csj=</span><span class="ot">NA</span>,
                                  <span class="dt">csminusj=</span><span class="ot">NA</span>,
                                  <span class="dt">cdj=</span><span class="ot">NA</span>,
                                  <span class="dt">cdminusj=</span><span class="ot">NA</span>,
                                  <span class="dt">caj=</span><span class="ot">NA</span>,
                                  <span class="dt">caminusj=</span><span class="ot">NA</span>)))
    }
  <span class="co">#Construct a data.table to return</span>
  eff.dt &lt;-<span class="st"> </span><span class="kw">as.data.table</span>(<span class="kw">do.call</span>(rbind.data.frame,
                                  eff.list),
                          <span class="dt">keep.rownames=</span><span class="ot">TRUE</span>)
  eff.dt[, chemcas:<span class="er">=</span>this.chemcas]
  <span class="kw">return</span>(eff.dt)
  }</code></pre></div>
</div>
<div id="for-each-subpopulation" class="section level1">
<h1>For each subpopulation</h1>
<p>Now take one more step out and define a function to do for each subpopulation.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">doforeachsubpop &lt;-<span class="st"> </span>function(ecg, <span class="co">#Short for &quot;ExpoCast group&quot;</span>
                            nsamp,
                            chemlist, <span class="co">#list of chemicals to loop over</span>
                            model, <span class="co">#HTTK model to use</span>
                            <span class="dt">species =</span> <span class="st">'Human'</span>, <span class="co">#HTTK species to use </span>
                            <span class="dt">sigma.factor =</span> <span class="fl">0.3</span>, <span class="co">#Coefficient of variation</span>
                            <span class="dt">css.method =</span> <span class="st">'analytic'</span>, <span class="co">#or 'full'</span>
                            poormetab, <span class="co">#TRUE or FALSE</span>
                            fup.censor, <span class="co">#TRUE or FALSE</span>
                            cluster){ <span class="co">#The parallel cluster to use (we'll parallelize the loop over chemicals)</span>
  <span class="co">#First read in the virtual population data.</span>
  indiv1.dt&lt;-<span class="kw">readRDS</span>(<span class="kw">paste0</span>(<span class="st">'data/httkpop_'</span>,
                            <span class="st">'dr'</span>,
                            <span class="st">'_'</span>,
                            ecg,
                            <span class="st">'.Rdata'</span>))
  indiv2.dt&lt;-<span class="kw">readRDS</span>(<span class="kw">paste0</span>(<span class="st">'data/httkpop_'</span>,
                            <span class="st">'dr'</span>,
                            <span class="st">'_'</span>,
                            ecg,
                            <span class="st">'2.Rdata'</span>))
  
  <span class="co">#Convert the biological parameters first</span>
  indiv.model.bio1 &lt;-<span class="st"> </span>httk::<span class="kw">httkpop_bio</span>(<span class="dt">indiv_dt=</span>indiv1.dt)
  indiv.model.bio2 &lt;-<span class="st"> </span>httk::<span class="kw">httkpop_bio</span>(<span class="dt">indiv_dt=</span>indiv2.dt)
  
  <span class="co">#Now loop over the chemicals</span>
  eff.allchems &lt;-<span class="st"> </span><span class="kw">rbindlist</span>(
    <span class="kw">parLapplyLB</span>(<span class="dt">cl=</span>cluster,
                chemlist, 
                doforeachchem,
                <span class="dt">model=</span>model, 
                <span class="dt">species=</span>species, 
                <span class="dt">sigma.factor=</span>sigma.factor,
                <span class="dt">css.method=</span>css.method,
                <span class="dt">indiv.model.bio1=</span>indiv.model.bio1,
                <span class="dt">indiv.model.bio2=</span>indiv.model.bio2,
                <span class="dt">ExpoCast.group=</span>ecg,
                <span class="dt">poormetab=</span>poormetab,
                <span class="dt">fup.censor=</span>fup.censor,
                <span class="dt">nsamp=</span>nsamp))
  <span class="co">#Add a column to the data.table denoting the subpopulation</span>
  eff.allchems[,ExpoCast.group:<span class="er">=</span>ecg]
  <span class="co">#And return the output</span>
  <span class="kw">return</span>(eff.allchems)
  }</code></pre></div>
</div>
<div id="loop-over-subpopulations" class="section level1">
<h1>Loop over subpopulations</h1>
<p>Excellent! All that remains is to write the loop over the subpopulations that will call all of these functions in turn. We’ll also add loops over the values of <code>poormetab</code> and <code>Funbound.plasma</code>, to see if and how global sensitivity changes under different conditions on the distributions of those variables.</p>
<p><strong>WARNING: this code may take a LONG time to run!</strong> 4 model evaluations per individual times 1000 individuals times 3 parameters times about 500 chemicals times 10 subpopulations = 6e7 model evaluations, plus overhead. While the model evaluations are vectorized for the analytic steady-state models – so 1000 model evaluations take very little time – this still can add up. On my machine, it took about 7 minutes for each combination of CLint and Funbound conditions, and about half an hour total – and that is parallelized with 10 cores.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">model &lt;-<span class="st"> &quot;3compartmentss&quot;</span>
species &lt;-<span class="st"> &quot;Human&quot;</span>
sigma.factor &lt;-<span class="st"> </span><span class="fl">0.3</span>
css.method &lt;-<span class="st"> &quot;analytic&quot;</span>
chemlist &lt;-<span class="st"> </span>httk::<span class="kw">get_cheminfo</span>(<span class="dt">info=</span><span class="st">&quot;CAS&quot;</span>,
                               <span class="dt">exclude.fub.zero=</span><span class="ot">FALSE</span>)

cluster &lt;-<span class="st"> </span>parallel::<span class="kw">makeCluster</span>(<span class="dv">40</span>, 
                                 <span class="dt">outfile=</span><span class="st">'globalsens_parallel_out.txt'</span>)

evalout &lt;-<span class="st"> </span>parallel::<span class="kw">clusterEvalQ</span>(<span class="dt">cl=</span>cluster,
                                  {<span class="kw">library</span>(data.table)
                                   <span class="kw">library</span>(httk)})
parallel::<span class="kw">clusterExport</span>(<span class="dt">cl =</span> cluster,
                        <span class="dt">varlist =</span> <span class="kw">c</span>(<span class="st">'doforeachparam'</span>,
                                    <span class="st">'doforeachchem'</span>,
                                    <span class="st">'doforeachsubpop'</span>))
<span class="co">#Set seeds on all workers for reproducibility</span>
parallel::<span class="kw">clusterSetRNGStream</span>(cluster, 
                              TeachingDemos::<span class="kw">char2seed</span>(<span class="st">&quot;Caroline Ring&quot;</span>))

<span class="kw">system.time</span>({for (poormetab in <span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>)){
  for (fup.censor in <span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>)) {
    eff.all&lt;-<span class="kw">rbindlist</span>(<span class="kw">lapply</span>(ExpoCast.group,
                              doforeachsubpop,
                              <span class="dt">nsamp=</span>nsamp,
                              <span class="dt">chemlist=</span>chemlist,
                              <span class="dt">model=</span>model, 
                              <span class="dt">species=</span>species,
                              <span class="dt">sigma.factor=</span>sigma.factor,
                              <span class="dt">css.method=</span>css.method,
                              <span class="dt">poormetab=</span>poormetab,
                              <span class="dt">fup.censor=</span>fup.censor,
                              <span class="dt">cluster=</span>cluster))
    <span class="kw">saveRDS</span>(eff.all, 
            <span class="kw">paste0</span>(<span class="st">'data/'</span>,
                   <span class="st">'sens_glenisaacs_nhanes_'</span>, 
                   <span class="st">'allchems_'</span>,
                   <span class="st">'allgroups_'</span>,
                   model,
                   <span class="st">'_'</span>,
                   css.method,
                   <span class="st">'_fup_censor_'</span>,
                   fup.censor,
                   <span class="st">'_poormetab_'</span>,
                   poormetab,
                   <span class="st">&quot;_FuptoFub&quot;</span>,
                   <span class="st">'.Rdata'</span>))
    }
  }
  })
parallel::<span class="kw">stopCluster</span>(cluster)</code></pre></div>
<p>Finally, we want to do sensitivity analysis for independent Monte Carlo, because that lets us estimate sensitivity to each physiological parameter independently.</p>
<p>The first thing we need to do is generate two separate populations using independent Monte Carlo. To save space, we’ll set this up as a function that takes the seed as an argument.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">indep_gen &lt;-<span class="st"> </span>function(<span class="dt">nsamp=</span><span class="dv">1000</span>, <span class="dt">sigma.factor=</span><span class="fl">0.3</span>){
  
  COmean &lt;-<span class="st"> </span>physiology.data[physiology.data$Parameter==<span class="st">'Cardiac Output'</span>,
                               <span class="st">'Human'</span>]
  indep.bio &lt;-<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">Qcardiacc=</span>truncnorm::<span class="kw">rtruncnorm</span>(<span class="dt">n=</span>nsamp,
                                                          <span class="dt">mean=</span>COmean,
                                                          <span class="dt">sd=</span>sigma.factor*COmean,
                                                          <span class="dt">a=</span><span class="dv">0</span>)/<span class="dv">1000</span>*<span class="dv">60</span>)
  indep.bio[, BW:<span class="er">=</span>truncnorm::<span class="kw">rtruncnorm</span>(<span class="dt">n=</span>nsamp,
                                        <span class="dt">mean=</span>physiology.data[physiology.data$Parameter==<span class="st">'Average BW'</span>,
                                                                <span class="st">'Human'</span>],
                                        <span class="dt">sd=</span>sigma.factor*physiology.data[physiology.data$Parameter==<span class="st">'Average BW'</span>,
                                                                           <span class="st">'Human'</span>],
                                        <span class="dt">a=</span><span class="dv">0</span>)]
  indep.bio[, plasma.vol:<span class="er">=</span>truncnorm::<span class="kw">rtruncnorm</span>(<span class="dt">n=</span>nsamp,
                                                <span class="dt">mean=</span>physiology.data[physiology.data$Parameter==<span class="st">'Plasma Volume'</span>,
                                                                        <span class="st">'Human'</span>],
                                                <span class="dt">sd=</span>sigma.factor*physiology.data[physiology.data$Parameter==<span class="st">'Plasma Volume'</span>,
                                                                                   <span class="st">'Human'</span>],
                                                <span class="dt">a=</span><span class="dv">0</span>)/<span class="dv">1000</span>] <span class="co">#convert mL/kg to L/kg</span>
  indep.bio[, hematocrit:<span class="er">=</span>truncnorm::<span class="kw">rtruncnorm</span>(<span class="dt">n=</span>nsamp,
                                                <span class="dt">mean=</span>physiology.data[physiology.data$Parameter==<span class="st">'Hematocrit'</span>,
                                                                        <span class="st">'Human'</span>],
                                                <span class="dt">sd=</span>sigma.factor*physiology.data[physiology.data$Parameter==<span class="st">'Hematocrit'</span>,
                                                                                   <span class="st">'Human'</span>],
                                                <span class="dt">a=</span><span class="dv">0</span>,
                                                <span class="dt">b=</span><span class="dv">1</span>)]
  indep.bio[, million.cells.per.gliver:<span class="er">=</span>truncnorm::<span class="kw">rtruncnorm</span>(<span class="dt">n=</span>nsamp,
                                                              <span class="dt">mean=</span><span class="dv">110</span>,
                                                              <span class="dt">sd=</span>sigma.factor*<span class="dv">110</span>,
                                                              <span class="dt">a=</span><span class="dv">0</span>)]
  
  all.tissues &lt;-<span class="st"> </span>tissue.data$Tissue[tissue.data$Tissue!=<span class="st">'red blood cells'</span>]
  for (tissue in all.tissues){
    vol.mean &lt;-<span class="st"> </span>tissue.data[tissue.data$Tissue==tissue,
                            <span class="st">'Human Vol (L/kg)'</span>]
    flow.mean &lt;-<span class="st"> </span>tissue.data[tissue.data$Tissue==tissue,
                             <span class="st">'Human Flow (mL/min/kg^(3/4))'</span>]/
<span class="st">      </span><span class="dv">1000</span>*<span class="dv">60</span>
    if (tissue==<span class="st">'liver'</span>){ <span class="co">#subtract gut flow from portal vein flow</span>
      <span class="co">#to get arterial flow</span>
      flow.mean &lt;-<span class="st"> </span>(tissue.data[tissue.data$Tissue==<span class="st">'liver'</span>,
                                <span class="st">'Human Flow (mL/min/kg^(3/4))'</span>] -
<span class="st">                      </span>tissue.data[tissue.data$Tissue==<span class="st">'gut'</span>,
                                  <span class="st">'Human Flow (mL/min/kg^(3/4))'</span>])/
<span class="st">        </span><span class="dv">1000</span>*<span class="dv">60</span>
      }
    indep.bio[, <span class="kw">paste0</span>(<span class="st">'V'</span>,
                       tissue,
                       <span class="st">'c'</span>):<span class="er">=</span>truncnorm::<span class="kw">rtruncnorm</span>(<span class="dt">n=</span>nsamp,
                                                   <span class="dt">mean=</span>vol.mean,
                                                   <span class="dt">sd=</span>sigma.factor*vol.mean,
                                                   <span class="dt">a=</span><span class="dv">0</span>)]
    indep.bio[, <span class="kw">paste0</span>(<span class="st">'Q'</span>,
                       tissue,
                       <span class="st">'f'</span>):<span class="er">=</span>truncnorm::<span class="kw">rtruncnorm</span>(<span class="dt">n=</span>nsamp,
                                                   <span class="dt">mean=</span>flow.mean,
                                                   <span class="dt">sd=</span>sigma.factor*flow.mean,
                                                   <span class="dt">a=</span><span class="dv">0</span>)/Qcardiacc]
    }
  
  
  
  indep.bio[, Qtotal.liverc:<span class="er">=</span>(Qliverf+Qgutf)*Qcardiacc]
  indep.bio[, liver.density:<span class="er">=</span><span class="fl">1.05</span>]
  gfr.mean&lt;-physiology.data[physiology.data$Parameter==<span class="st">'GFR'</span>,
                               <span class="st">'Human'</span>]*<span class="dv">60</span>/<span class="dv">1000</span> <span class="co">#convert from ml/min/kg^(3/4) to L/hr/kg(3/4)</span>
  indep.bio[, Qgfrc:<span class="er">=</span>truncnorm::<span class="kw">rtruncnorm</span>(<span class="dt">n=</span>nsamp,
                                           <span class="dt">mean=</span>gfr.mean,
                                           <span class="dt">sd=</span>sigma.factor*gfr.mean,
                                           <span class="dt">a=</span><span class="dv">0</span>)]
  indep.bio[, 
            Vartc:<span class="er">=</span><span class="st"> </span>plasma.vol/
<span class="st">              </span>(<span class="dv">1</span>-hematocrit)/<span class="dv">2</span>] <span class="co">#L/kgBW</span>
  indep.bio[, 
            Vvenc:<span class="er">=</span><span class="st"> </span>plasma.vol/
<span class="st">              </span>(<span class="dv">1</span>-hematocrit)/<span class="dv">2</span>] <span class="co">#L/kgBW</span>
  <span class="kw">return</span>(indep.bio)
  }</code></pre></div>
<p>And then we call it twice to get two different populations.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">TeachingDemos::<span class="kw">char2seed</span>(<span class="st">&quot;Caroline Ring&quot;</span>)
indep.bio1 &lt;-<span class="st"> </span><span class="kw">indep_gen</span>()
indep.bio2 &lt;-<span class="st"> </span><span class="kw">indep_gen</span>()</code></pre></div>
<p>The innermost function (over parameters) will be the same, but we need to modify the function of things to do for each chemical, because we need to do sensitivity analysis for the physiological parameters independently, not as a group.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">doforeachchem_indep &lt;-<span class="st"> </span>function(this.chemcas, <span class="co">#CAS for one chemical </span>
                                model, <span class="co">#HTTK model to use</span>
                                <span class="dt">species=</span><span class="st">'Human'</span>, <span class="co">#Species for HTTK</span>
                                nsamp, <span class="co">#Number of people in virtual population</span>
                                css.method, <span class="co">#'analytic' or 'full'</span>
                                <span class="dt">sigma.factor=</span><span class="fl">0.3</span>, <span class="co">#coefficient of variation</span>
                                indep.model.bio1, <span class="co">#output of indep_gen()</span>
                                indep.model.bio2, <span class="co">#output of indep_gen()</span>
                                poormetab, <span class="co">#TRUE or FALSE</span>
                                fup.censor){  <span class="co">#TRUE or FALSE</span>
  <span class="co">#To avoid making changes outside the function</span>
  indiv.model.bio1 &lt;-<span class="st"> </span><span class="kw">copy</span>(indep.model.bio1)
  indiv.model.bio2 &lt;-<span class="st"> </span><span class="kw">copy</span>(indep.model.bio2)
  
  <span class="co">#First draw Funbound.plasma and Clint</span>
  indiv.A &lt;-<span class="st"> </span>httk::<span class="kw">draw_fup_clint</span>(<span class="dt">this.chem=</span>this.chemcas,
                                     <span class="dt">indiv.bio.tmp=</span>indiv.model.bio1,
                                     <span class="dt">sigma.factor=</span>sigma.factor,
                                     <span class="dt">poormetab=</span>poormetab,
                                     <span class="dt">fup.censor=</span>fup.censor)
  indiv.B &lt;-<span class="st"> </span>httk::<span class="kw">draw_fup_clint</span>(<span class="dt">this.chem=</span>this.chemcas,
                                     <span class="dt">indiv.bio.tmp=</span>indiv.model.bio2,
                                     <span class="dt">sigma.factor=</span>sigma.factor,
                                     <span class="dt">poormetab=</span>poormetab,
                                     <span class="dt">fup.censor=</span>fup.censor)
  <span class="co">#Convert to HTTK parameters for matrix A and matrix B</span>
  indiv.A.httk &lt;-<span class="st"> </span>httk::<span class="kw">convert_httk</span>(<span class="dt">indiv.model.bio =</span> indiv.A,
                                        <span class="dt">model =</span> model,
                                        <span class="dt">this.chem =</span> this.chemcas)
  indiv.B.httk &lt;-<span class="st"> </span>httk::<span class="kw">convert_httk</span>(<span class="dt">indiv.model.bio =</span> indiv.B,
                                        <span class="dt">model =</span> model,
                                        <span class="dt">this.chem =</span> this.chemcas)
  
  <span class="co">#If model is 3compartmentss, convert Funbound.plasma to Funbound.blood</span>
  if (model==<span class="st">&quot;3compartmentss&quot;</span>){
    <span class="co">#First, get the default parameters used for the Schmitt method of estimating</span>
    <span class="co">#partition coefficients.</span>
    pschmitt &lt;-<span class="st"> </span>httk::<span class="kw">parameterize_schmitt</span>(<span class="dt">chem.cas=</span>this.chemcas,
                                           <span class="dt">species=</span><span class="st">'Human'</span>)
    convert_Fup &lt;-<span class="st"> </span>function(DT.bio, DT.httk, pschmitt, this.chemcas){
      DT.bio &lt;-<span class="st"> </span><span class="kw">copy</span>(DT.bio)
      DT.httk &lt;-<span class="st"> </span><span class="kw">copy</span>(DT.httk)
    <span class="co">#next, replace the single default value for Funbound.plasma with the vector</span>
    <span class="co">#of Funbound.plasma values from the virtual population data.table.</span>
    pschmitt$Funbound.plasma&lt;-DT.httk[, Funbound.plasma]
    <span class="co">#Now, predict the partitioning coefficients using Schmitt's method. The</span>
    <span class="co">#result will be a list of numerical vectors, one vector for each</span>
    <span class="co">#tissue-to-plasma partitioning coefficient, and one element of each vector</span>
    <span class="co">#for each individual. The list element names specify which partition</span>
    <span class="co">#coefficient it is, e.g. Kliver2plasma, Kgut2plasma, etc.</span>
    PCs &lt;-<span class="st"> </span>httk::<span class="kw">predict_partitioning_schmitt</span>(<span class="dt">parameters=</span>pschmitt,
                                              <span class="dt">chem.cas=</span>this.chemcas,
                                              <span class="dt">species=</span><span class="st">'Human'</span>)
    Rb2p &lt;-<span class="st"> </span><span class="dv">1</span> -<span class="st"> </span>DT.bio$hematocrit +<span class="st"> </span>DT.bio$hematocrit *<span class="st"> </span>
<span class="st">      </span>PCs[[<span class="st">&quot;Krbc2pu&quot;</span>]] *<span class="st"> </span>
<span class="st">      </span>DT.httk$Funbound.plasma
    
  Funbound.blood &lt;-<span class="st"> </span>DT.httk$Funbound.plasma/Rb2p
  <span class="kw">return</span>(<span class="kw">list</span>(<span class="dt">Rb2p=</span>Rb2p,
              <span class="dt">Funbound.blood=</span>Funbound.blood))
  }
  
  Fconvert.A &lt;-<span class="st"> </span><span class="kw">convert_Fup</span>(<span class="dt">DT.bio=</span>indiv.A,
                                                <span class="dt">DT.httk=</span>indiv.A.httk,
                                                <span class="dt">pschmitt=</span>pschmitt,
                                                <span class="dt">this.chemcas=</span>this.chemcas)
  
  Fconvert.B &lt;-<span class="st"> </span><span class="kw">convert_Fup</span>(<span class="dt">DT.bio=</span>indiv.B,
                                                <span class="dt">DT.httk=</span>indiv.B.httk,
                                                <span class="dt">pschmitt=</span>pschmitt,
                                                <span class="dt">this.chemcas=</span>this.chemcas)
  
  indiv.A.httk[, Funbound.plasma:<span class="er">=</span>Fconvert.A$Funbound.blood]
  indiv.B.httk[, Funbound.plasma:<span class="er">=</span>Fconvert.B$Funbound.blood]
  }
  <span class="co">#Evaluate model</span>
  if (<span class="kw">tolower</span>(css.method)==<span class="st">'analytic'</span>) {
    f.A &lt;-<span class="st"> </span>httk::<span class="kw">calc_analytic_css</span>(<span class="dt">chem.cas=</span>this.chemcas,
                                   <span class="dt">parameters=</span>indiv.A.httk,
                                   <span class="dt">daily.dose=</span><span class="dv">1</span>, 
                                   <span class="dt">output.units=</span><span class="st">&quot;uM&quot;</span>,
                                   <span class="dt">model=</span>model,
                                   <span class="dt">species=</span>species,
                                   <span class="dt">suppress.messages=</span><span class="ot">TRUE</span>,
                                   <span class="dt">recalc.blood2plasma=</span><span class="ot">TRUE</span>)
    f.B &lt;-<span class="st"> </span>httk::<span class="kw">calc_analytic_css</span>(<span class="dt">chem.cas=</span>this.chemcas,
                                   <span class="dt">parameters=</span>indiv.B.httk,
                                   <span class="dt">daily.dose=</span><span class="dv">1</span>, 
                                   <span class="dt">output.units=</span><span class="st">&quot;uM&quot;</span>,
                                   <span class="dt">model=</span>model,
                                   <span class="dt">species=</span>species,
                                   <span class="dt">suppress.messages=</span><span class="ot">TRUE</span>,
                                   <span class="dt">recalc.blood2plasma=</span><span class="ot">TRUE</span>)
    if (model==<span class="st">&quot;3compartmentss&quot;</span>){
      f.A &lt;-<span class="st"> </span>f.A/Fconvert.A$Rb2p
      f.B &lt;-<span class="st"> </span>f.B/Fconvert.B$Rb2p
    }
    }
  else if (<span class="kw">tolower</span>(css.method)==<span class="st">'full'</span>){
    f.A &lt;-<span class="st"> </span><span class="kw">apply</span>(<span class="dt">X=</span>indiv.A.httk, 
                 <span class="dt">MARGIN=</span><span class="dv">1</span>,
                 <span class="dt">FUN=</span>function(x) httk::<span class="kw">calc_css</span>(<span class="dt">chem.cas=</span>this.chemcas,
                                                <span class="dt">parameters=</span><span class="kw">as.list</span>(x),
                                                <span class="dt">daily.dose=</span><span class="dv">1</span>, 
                                                <span class="dt">output.units=</span><span class="st">&quot;uM&quot;</span>,
                                                <span class="dt">model=</span>model,
                                                <span class="dt">species=</span>species,
                                                <span class="dt">suppress.messages=</span><span class="ot">TRUE</span>,
                                                <span class="dt">f.change=</span><span class="fl">1e-5</span>)[[<span class="st">'avg'</span>]])
    f.B &lt;-<span class="st"> </span><span class="kw">apply</span>(<span class="dt">X=</span>indiv.B.httk, 
                 <span class="dt">MARGIN=</span><span class="dv">1</span>,
                 <span class="dt">FUN=</span>function(x) httk::<span class="kw">calc_css</span>(<span class="dt">chem.cas=</span>this.chemcas,
                                                <span class="dt">parameters=</span><span class="kw">as.list</span>(x),
                                                <span class="dt">daily.dose=</span><span class="dv">1</span>, 
                                                <span class="dt">output.units=</span><span class="st">&quot;uM&quot;</span>,
                                                <span class="dt">model=</span>model,
                                                <span class="dt">species=</span>species,
                                                <span class="dt">suppress.messages=</span><span class="ot">TRUE</span>,
                                                <span class="dt">f.change=</span><span class="fl">1e-5</span>)[[<span class="st">'avg'</span>]])
    }
  <span class="co">#Compute normalized data (number of standard deviations from the mean)</span>
  g0&lt;-(f.A-<span class="kw">mean</span>(f.A))/<span class="kw">sqrt</span>(<span class="kw">var</span>(f.A) *<span class="st"> </span>(<span class="kw">length</span>(f.A)-<span class="dv">1</span>) /<span class="st"> </span><span class="kw">length</span>(f.A))
  g0prime &lt;-<span class="st"> </span>(f.B-<span class="kw">mean</span>(f.B))/<span class="kw">sqrt</span>(<span class="kw">var</span>(f.B) *<span class="st"> </span>(<span class="kw">length</span>(f.B)-<span class="dv">1</span>) /<span class="st"> </span><span class="kw">length</span>(f.B))
  
  <span class="co">#Compute spurious correlation term between f.A and f.B</span>
  p0 &lt;-<span class="st"> </span><span class="kw">mean</span>(g0*g0prime)
  
  <span class="co">#Next, define the list of HTTK parameters that constitute the physiological parameters for this model.</span>
  <span class="co">#Strictly speaking this should be all of the columns in indiv.model.bio1, except for liver.density, which is a fixed value.</span>
<span class="co">#   #From previous runs, these are the only parameters that the models are sensitive to</span>
  phys.par &lt;-<span class="st"> </span>switch(model,
                     <span class="st">'pbtk'</span>=<span class="kw">c</span>(<span class="st">'BW'</span>,
                              <span class="st">'hematocrit'</span>,
                              <span class="st">'million.cells.per.gliver'</span>,
                              <span class="st">'Qcardiacc'</span>,
                              <span class="st">'Qgfrc'</span>,
                              <span class="st">'Qgutf'</span>,
                              <span class="st">'Qkidneyf'</span>,
                              <span class="st">'Qliverf'</span>,
                              <span class="st">'Vliverc'</span>),
                     <span class="st">'3compartment'</span>=<span class="kw">c</span>(<span class="st">'BW'</span>,
                                      <span class="st">'hematocrit'</span>,
                                      <span class="st">'million.cells.per.gliver'</span>,
                                      <span class="st">'Qgfrc'</span>,
                                      <span class="st">'Qgutf'</span>,
                                      <span class="st">'Qliverf'</span>,
                                      <span class="st">'Vliverc'</span>),
                     <span class="st">'3compartmentss'</span>=<span class="kw">c</span>(<span class="st">'BW'</span>,
                                        <span class="st">'million.cells.per.gliver'</span>,
                                        <span class="st">'Qgfrc'</span>,
                                        <span class="st">'Qtotal.liverc'</span>,
                                        <span class="st">'Vliverc'</span>),
                     <span class="st">'1compartment'</span>=<span class="kw">c</span>(<span class="st">'BW'</span>,
                                      <span class="st">'million.cells.per.gliver'</span>,
                                      <span class="st">'Qgfrc'</span>,
                                      <span class="st">'Qtotal.liverc'</span>,
                                      <span class="st">'Vliverc'</span>))
phys.par.all &lt;-<span class="st"> </span><span class="kw">names</span>(indiv.model.bio1)[<span class="kw">names</span>(indiv.model.bio1)!=
<span class="st">                                            'liver.density'</span>]
  parlist &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="st">'Clint'</span>,
                  <span class="st">'Funbound.plasma'</span>,
                  phys.par.all)
  
  parlist &lt;-<span class="st"> </span><span class="kw">c</span>(parlist, <span class="kw">as.list</span>(phys.par))
  <span class="co">#Note: Now sensitivity is being calculated to each of the physiological parameter independently, as well as grouped.</span>
  
  <span class="co">#If Clint is fixed at zero,</span>
  <span class="co">#don't test sensitivity to it</span>
  if (<span class="kw">all</span>(indiv.A[, Clint]==<span class="dv">0</span>)){
    parlist &lt;-<span class="st"> </span>parlist[parlist!=<span class="st">'Clint'</span>]
    }
  
  <span class="co">#Now loop over parameters (and groups thereof)</span>
  eff.list &lt;-<span class="st"> </span><span class="kw">lapply</span>(parlist,
                     doforeachparam,
                     <span class="dt">indiv.A=</span>indiv.A,
                     <span class="dt">indiv.B=</span>indiv.B,
                     <span class="dt">this.chemcas=</span>this.chemcas,
                     <span class="dt">model=</span>model,
                     <span class="dt">species=</span>species,
                     <span class="dt">css.method=</span>css.method,
                     <span class="dt">f.A=</span>f.A,
                     <span class="dt">f.B=</span>f.B,
                     <span class="dt">g0=</span>g0,
                     <span class="dt">g0prime=</span>g0prime,
                     <span class="dt">p0=</span>p0)
  
  parnames &lt;-<span class="st"> </span>parlist
  <span class="co">#Name the sensitivity indexes by their parameters</span>
  <span class="co">#For the group of physiological parameters, just name it &quot;phys.par&quot;</span>
  parnames[<span class="kw">sapply</span>(parnames, function(x) <span class="kw">length</span>(x)&gt;<span class="dv">1</span>)] &lt;-<span class="st"> 'phys.par'</span>
  <span class="kw">names</span>(eff.list) &lt;-<span class="st"> </span>parnames
  
  <span class="co">#If Clint was zero, then sensitivity to it wasn't calculated.</span>
  <span class="co">#Set all the sensitivity quantities to NA to indicate this.</span>
  if (<span class="kw">all</span>(indiv.A[, Clint]==<span class="dv">0</span>)){
    eff.list &lt;-<span class="st"> </span><span class="kw">c</span>(eff.list,
                  <span class="kw">list</span>(<span class="dt">Clint=</span><span class="kw">list</span>(<span class="dt">Ti=</span><span class="ot">NA</span>,
                                  <span class="dt">Si=</span><span class="ot">NA</span>,
                                  <span class="dt">p0=</span><span class="ot">NA</span>,
                                  <span class="dt">pj=</span><span class="ot">NA</span>,
                                  <span class="dt">csj=</span><span class="ot">NA</span>,
                                  <span class="dt">csminusj=</span><span class="ot">NA</span>,
                                  <span class="dt">cdj=</span><span class="ot">NA</span>,
                                  <span class="dt">cdminusj=</span><span class="ot">NA</span>,
                                  <span class="dt">caj=</span><span class="ot">NA</span>,
                                  <span class="dt">caminusj=</span><span class="ot">NA</span>)))
    }
  <span class="co">#Construct a data.table to return</span>
  eff.dt &lt;-<span class="st"> </span><span class="kw">as.data.table</span>(<span class="kw">do.call</span>(rbind.data.frame,
                                  eff.list),
                          <span class="dt">keep.rownames=</span><span class="ot">TRUE</span>)
  eff.dt[, chemcas:<span class="er">=</span>this.chemcas]
  <span class="kw">return</span>(eff.dt)
  }</code></pre></div>
<p>And finally, loop over the chemicals to actually do the sensitivity analysis.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">model &lt;-<span class="st"> &quot;3compartmentss&quot;</span>
species &lt;-<span class="st"> &quot;Human&quot;</span>
sigma.factor &lt;-<span class="st"> </span><span class="fl">0.3</span>
css.method &lt;-<span class="st"> &quot;analytic&quot;</span>
chemlist &lt;-<span class="st"> </span>httk::<span class="kw">get_cheminfo</span>(<span class="dt">info=</span><span class="st">&quot;CAS&quot;</span>,
                               <span class="dt">exclude.fub.zero=</span><span class="ot">FALSE</span>)

cluster &lt;-<span class="st"> </span>parallel::<span class="kw">makeCluster</span>(<span class="dv">40</span>, 
                                 <span class="dt">outfile=</span><span class="st">'globalsens_indep_parallel_out.txt'</span>)

evalout &lt;-<span class="st"> </span>parallel::<span class="kw">clusterEvalQ</span>(<span class="dt">cl=</span>cluster,
                                  {<span class="kw">library</span>(data.table)
                                   <span class="kw">library</span>(httk)})
parallel::<span class="kw">clusterExport</span>(<span class="dt">cl =</span> cluster,
                        <span class="dt">varlist =</span> <span class="kw">c</span>(<span class="st">'doforeachparam'</span>))
<span class="co">#Set seeds on all workers for reproducibility</span>
parallel::<span class="kw">clusterSetRNGStream</span>(cluster, 
                              TeachingDemos::<span class="kw">char2seed</span>(<span class="st">&quot;Caroline Ring&quot;</span>))
for (poormetab in <span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>)){
  for (fup.censor in <span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>)) {
    <span class="co">#Now loop over the chemicals</span>
    eff.allchems &lt;-<span class="st"> </span><span class="kw">rbindlist</span>(
      <span class="kw">parLapplyLB</span>(<span class="dt">cl=</span>cluster,
                  chemlist, 
                  doforeachchem_indep,
                  <span class="dt">model=</span>model, 
                  <span class="dt">species=</span>species, 
                  <span class="dt">sigma.factor=</span>sigma.factor,
                  <span class="dt">css.method=</span>css.method,
                  <span class="dt">indep.model.bio1=</span>indep.bio1,
                  <span class="dt">indep.model.bio2=</span>indep.bio2,
                  <span class="dt">poormetab=</span>poormetab,
                  <span class="dt">fup.censor=</span>fup.censor,
                  <span class="dt">nsamp=</span><span class="dv">1000</span>))
    <span class="kw">saveRDS</span>(eff.allchems, 
            <span class="kw">paste0</span>(<span class="st">'data/'</span>,
                   <span class="st">'sens_glenisaacs_nhanes_'</span>, 
                   <span class="st">'allchems_'</span>,
                   <span class="st">'indepMC_'</span>,
                   model,
                   <span class="st">'_'</span>,
                   css.method,
                   <span class="st">'_fup_censor_'</span>,
                   fup.censor,
                   <span class="st">'_poormetab_'</span>,
                   poormetab,
                   <span class="st">&quot;_FuptoFub&quot;</span>,
                   <span class="st">'.Rdata'</span>))
    }
  }
parallel::<span class="kw">stopCluster</span>(cluster)</code></pre></div>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>

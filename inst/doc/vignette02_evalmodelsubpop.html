<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Caroline Ring" />

<meta name="date" content="2017-07-14" />

<title>Vignette 2: Evaluating HTTK models for subpopulations</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">Vignette 2: Evaluating HTTK models for subpopulations</h1>
<h4 class="author"><em>Caroline Ring</em></h4>
<h4 class="date"><em>2017-07-14</em></h4>



<p>Once you have generated virtual population data for each subpopulation, you probably want to do something with that data – like run an HTTK model over each population. This vignette describes how to do that.</p>
<p>Before running the code in this vignette, you need to generate the virtual subpopulations by running the code in the <a href="vignette01_subpopulations.html">Generating subpopulations</a> vignette.</p>
<p>To use the code in this vignette, you’ll first need to load a few packages (if you haven’t already).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(httk)
<span class="kw">library</span>(data.table)
<span class="kw">library</span>(EnvStats)
<span class="co">#&gt; Warning: package 'EnvStats' was built under R version 3.4.1</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Attaching package: 'EnvStats'</span>
<span class="co">#&gt; The following objects are masked from 'package:survey':</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;     calibrate, cv</span>
<span class="co">#&gt; The following object is masked from 'package:Matrix':</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;     print</span>
<span class="co">#&gt; The following objects are masked from 'package:stats':</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;     predict, predict.lm</span>
<span class="co">#&gt; The following object is masked from 'package:base':</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;     print.default</span></code></pre></div>
<div id="running-the-httk-models" class="section level1">
<h1>Running the HTTK models</h1>
<p>The HTTK models are all general (chemical-independent) models, which means that in order to run them, you need to specify a chemical for which they can be parameterized. Let’s loop over all the chemicals in the HTTK data set. First, get a list of all of their CAS numbers.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">chemlist &lt;-<span class="st"> </span>httk::<span class="kw">get_cheminfo</span>(<span class="dt">info=</span><span class="st">'CAS'</span>, <span class="dt">exclude.fub.zero=</span><span class="ot">FALSE</span>)</code></pre></div>
</div>
<div id="things-to-do-for-each-chemical" class="section level1">
<h1>Things to do for each chemical</h1>
<p>Next, we set up a function to be applied for each chemical. For each chemical, we need to draw Monte Carlo samples for <code>funbound.plasma</code> and for <code>Clint</code>, because those values are chemical-specific. Then we need to convert the physiological parameters generated by <code>httkpop</code>, along with the <code>Funbound.plasma</code> and <code>Clint</code> values, into the parameters for a specified HTTK model. Finally, we need to actually run the HTTK model for the specified chemical, and compute Css (the steady-state plasma concentration). Here, we’re using a fixed dose of 1 mg/kg/day; these Css values will be used to compute oral equivalent doses later on.</p>
<p>Rather than storing all 1000 Css values for each chemical, we compute several percentiles of the Css distribution for each chemical and store those instead. We also use a non-parametric method (implemented in <code>EnvStats::eqnpar</code>) to estimate the confidence intervals around each percentile of the Css distribution.</p>
<p>This function returns one row of a data.table: the Css percentiles, their lower and upper confidence limits, and the CAS number. When this function is applied repeatedly over many chemicals, the rows can be bound together to form one big data.table over all the chemicals.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">doforeachchem &lt;-<span class="st"> </span>function(this.chemcas,  
                          model, 
                          species, 
                          sigma.factor,
                          css.method,
                          indiv.model.bio,
                          poormetab,
                          fup.censor,
                          ExpoCast.group,
                          nsamp,
                          Clint.vary){
  
  indiv.model.bio &lt;-<span class="st"> </span>data.table::<span class="kw">copy</span>(indiv.model.bio)
  <span class="co">#Convert to HTTK model params</span>
  if (ExpoCast.group==<span class="st">&quot;indepMC&quot;</span>){
    indiv.model.tmp &lt;-<span class="st"> </span><span class="kw">cbind</span>(indiv.model.bio,
                         httk::<span class="kw">draw_fup_clint</span>(<span class="dt">this.chem=</span>this.chemcas,
                                                 <span class="dt">nsamp=</span><span class="kw">nrow</span>(indiv.model.bio),
                                                 <span class="dt">poormetab=</span>poormetab,
                                                 <span class="dt">fup.censor=</span>fup.censor))
    indiv.model &lt;-<span class="st"> </span>httk::<span class="kw">convert_httk</span>(<span class="dt">indiv.model.bio=</span>indiv.model.tmp,
                                         <span class="dt">model=</span>model,
                                         <span class="dt">this.chem=</span>this.chemcas)
  }else{
  indiv.model &lt;-<span class="st"> </span>httk::<span class="kw">get_httk_params</span>(<span class="dt">indiv_dt=</span>indiv.model.bio,
                                       <span class="dt">model=</span>model,
                                       <span class="dt">chemcas=</span>this.chemcas,
                                       <span class="dt">poormetab=</span>poormetab,
                                       <span class="dt">fup.censor=</span>fup.censor,
                                       <span class="dt">Clint.vary=</span>Clint.vary)
  }
  
  <span class="co">#If model is 3compartmentss, convert Funbound.plasma to Funbound.blood</span>
  if (model==<span class="st">&quot;3compartmentss&quot;</span>){
  <span class="co">#First, get the default parameters used for the Schmitt method of estimating</span>
    <span class="co">#partition coefficients.</span>
    pschmitt &lt;-<span class="st"> </span>httk::<span class="kw">parameterize_schmitt</span>(<span class="dt">chem.cas=</span>this.chemcas,
                                           <span class="dt">species=</span><span class="st">'Human'</span>)
    <span class="co">#next, replace the single default value for Funbound.plasma with the vector</span>
    <span class="co">#of Funbound.plasma values from the virtual population data.table.</span>
    pschmitt$Funbound.plasma&lt;-indiv.model[, Funbound.plasma]
    
    <span class="co">#Now, predict the partitioning coefficients using Schmitt's method. The</span>
    <span class="co">#result will be a list of numerical vectors, one vector for each</span>
    <span class="co">#tissue-to-plasma partitioning coefficient, and one element of each vector</span>
    <span class="co">#for each individual. The list element names specify which partition</span>
    <span class="co">#coefficient it is, e.g. Kliver2plasma, Kgut2plasma, etc.</span>
    PCs &lt;-<span class="st"> </span>httk::<span class="kw">predict_partitioning_schmitt</span>(<span class="dt">parameters=</span>pschmitt,
                                              <span class="dt">chem.cas=</span>this.chemcas,
                                              <span class="dt">species=</span><span class="st">'Human'</span>)
    Rb2p &lt;-<span class="st"> </span><span class="dv">1</span> -<span class="st"> </span>indiv.model.bio$hematocrit +<span class="st"> </span>indiv.model.bio$hematocrit *<span class="st"> </span>
<span class="st">      </span>PCs[[<span class="st">&quot;Krbc2pu&quot;</span>]] *<span class="st"> </span>
<span class="st">      </span>indiv.model$Funbound.plasma
    
  indiv.model[, Funbound.plasma:<span class="er">=</span>Funbound.plasma/Rb2p]
  }
  
  <span class="co">#Evaluate model</span>
  if (<span class="kw">tolower</span>(css.method)==<span class="st">'analytic'</span>) {
    <span class="co">#Css</span>
    css &lt;-<span class="st"> </span>httk::<span class="kw">calc_analytic_css</span>(<span class="dt">chem.cas=</span>this.chemcas,
                                   <span class="dt">parameters=</span>indiv.model,
                                   <span class="dt">daily.dose=</span><span class="dv">1</span>, 
                                   <span class="dt">output.units=</span><span class="st">&quot;uM&quot;</span>,
                                   <span class="dt">model=</span>model,
                                   <span class="dt">species=</span>species,
                                   <span class="dt">suppress.messages=</span><span class="ot">TRUE</span>,
                                   <span class="dt">recalc.blood2plasma=</span><span class="ot">TRUE</span>)
    
    if (model==<span class="st">&quot;3compartmentss&quot;</span>){ <span class="co">#convert from Css.blood back to Css.plasma</span>
      css &lt;-<span class="st"> </span>css/Rb2p
    }
    }
  else if (<span class="kw">tolower</span>(css.method)==<span class="st">'full'</span>){
    <span class="co">#Css</span>
    css &lt;-<span class="st"> </span><span class="kw">apply</span>(<span class="dt">X=</span>indiv.model, 
                 <span class="dt">MARGIN=</span><span class="dv">1</span>,
                 <span class="dt">FUN=</span>function(x) httk::<span class="kw">calc_css</span>(<span class="dt">chem.cas=</span>this.chemcas,
                                                <span class="dt">parameters=</span><span class="kw">as.list</span>(x),
                                                <span class="dt">daily.dose=</span><span class="dv">1</span>, 
                                                <span class="dt">output.units=</span><span class="st">&quot;uM&quot;</span>,
                                                <span class="dt">model=</span>model,
                                                <span class="dt">species=</span>species,
                                                <span class="dt">suppress.messages=</span><span class="ot">TRUE</span>)[[<span class="st">'avg'</span>]])
    }
  <span class="co">#Compute percentiles</span>
  prob.vect &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="fl">0.01</span>, <span class="fl">0.05</span>,<span class="fl">0.1</span>,<span class="fl">0.25</span>,<span class="fl">0.5</span>,<span class="fl">0.75</span>,<span class="fl">0.9</span>,<span class="fl">0.95</span>, <span class="fl">0.99</span>)
  css.q &lt;-<span class="st"> </span><span class="kw">quantile</span>(css, <span class="dt">probs=</span>prob.vect)
  <span class="co">#Function to compute lower and upper CI bounds</span>
  tmpfun &lt;-<span class="st"> </span>function(x,z){
    tmp &lt;-<span class="st"> </span><span class="kw">tryCatch</span>(EnvStats::<span class="kw">eqnpar</span>(x,
                                     <span class="dt">p=</span>z,
                                     <span class="dt">ci=</span><span class="ot">TRUE</span>,
                                     <span class="dt">lb=</span><span class="dv">0</span>)$interval[[<span class="st">'limits'</span>]],
                    <span class="dt">error=</span>function(err){
                      <span class="kw">return</span>(<span class="kw">c</span>(<span class="dt">LCL=</span><span class="st">'NA'</span>, <span class="dt">UCL=</span><span class="st">'NA'</span>))
                      })
    <span class="kw">return</span>(tmp)
    }
  <span class="co">#Compute Css CI bounds</span>
  css.cl &lt;-<span class="st"> </span><span class="kw">sapply</span>(prob.vect, function(z) <span class="kw">tmpfun</span>(z, <span class="dt">x=</span>css)
                   )
  <span class="co">#Construct list to return</span>
  dat.chem.out &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">as.list</span>(css.q),
                       <span class="kw">as.list</span>(css.cl[<span class="st">'LCL'</span>,]),
                       <span class="kw">as.list</span>(css.cl[<span class="st">'UCL'</span>,]),
                       <span class="kw">as.list</span>(<span class="kw">var</span>(css)),
                       <span class="kw">as.list</span>(this.chemcas),
                       <span class="kw">as.list</span>(ExpoCast.group))
  <span class="kw">names</span>(dat.chem.out) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">paste0</span>(<span class="st">'css'</span>,<span class="dv">100</span>*prob.vect),
                           <span class="kw">paste0</span>(<span class="st">'LCL'</span>, <span class="st">'css'</span>, <span class="dv">100</span>*prob.vect),
                           <span class="kw">paste0</span>(<span class="st">'UCL'</span>, <span class="st">'css'</span>, <span class="dv">100</span>*prob.vect),
                           <span class="st">'var.css'</span>,
                           <span class="st">'chemcas'</span>,
                           <span class="st">'ExpoCast.group'</span>)
  <span class="kw">return</span>(dat.chem.out)
  }</code></pre></div>
</div>
<div id="looping-over-subpopulations-and-over-chemicals" class="section level1">
<h1>Looping over subpopulations and over chemicals</h1>
<p>So now, we need to loop over each of the subpopulations and then each of the chemicals.</p>
<p>We also need to choose a couple of settings – like whether poor metabolizers should be included in the <code>Clint</code> distribution, and whether the <code>Funbound.plasma</code> distribution should be censored or not. Let’s try it all ways, so we can compare them later on. Let’s also evaluate the model using both the virtual-individuals and direct-resampling populations, so we can compare those and see if there is a difference between the two ways of generating populations. (Spoiler alert: There isn’t.)</p>
<p><strong>Warning: the following code may take a while to run!</strong></p>
<p>Also note: This code was written for a machine where 10 processors were available. If you want to run on your own machine, you’ll need to change <code>numcluster</code> to a reasonable number of processors for your machine!</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">numcluster &lt;-<span class="st"> </span><span class="dv">40</span> <span class="co">#The number of processors to use in parallel</span>
<span class="co">#Note: This will depend on how many your machine has available!</span>
cluster &lt;-<span class="st"> </span>parallel::<span class="kw">makeCluster</span>(numcluster, <span class="dt">outfile=</span><span class="st">'subpoprun_parallel_out.txt'</span>)
parallel::<span class="kw">clusterEvalQ</span>(<span class="dt">cl=</span>cluster,
                       {<span class="kw">library</span>(httk)})
<span class="co">#Set seeds on all workers for reproducibility</span>
parallel::<span class="kw">clusterSetRNGStream</span>(cluster, 
                              TeachingDemos::<span class="kw">char2seed</span>(<span class="st">&quot;Caroline Ring&quot;</span>))
<span class="co">#List subpopulations</span>
ExpoCast.groups&lt;-<span class="kw">list</span>(<span class="st">&quot;Total&quot;</span>,
                      <span class="st">&quot;Age.6.11&quot;</span>,
                      <span class="st">&quot;Age.12.19&quot;</span>,
                      <span class="st">&quot;Age.20.65&quot;</span>,
                      <span class="st">&quot;Age.GT65&quot;</span>,
                      <span class="st">&quot;BMIgt30&quot;</span>,
                      <span class="st">&quot;BMIle30&quot;</span>,
                      <span class="st">&quot;Females&quot;</span>,
                      <span class="st">&quot;Males&quot;</span>,
                      <span class="st">&quot;ReproAgeFemale&quot;</span>,
                      <span class="st">&quot;Age.20.50.nonobese&quot;</span>)
<span class="co">#Evaluate model</span>
model &lt;-<span class="st"> '3compartmentss'</span>
popmethod &lt;-<span class="st"> &quot;dr&quot;</span>
  for (grp in ExpoCast.groups){
    for (poormetab in <span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>)){
      for (fup.censor in <span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>)) {
        <span class="co">#First read in population data.table</span>
        grp.dt &lt;-<span class="st"> </span><span class="kw">readRDS</span>(<span class="dt">file=</span><span class="kw">paste0</span>(<span class="st">'data/'</span>,<span class="kw">paste</span>(<span class="st">'httkpop'</span>,
                                                    popmethod,
                                                    grp, <span class="dt">sep=</span><span class="st">'_'</span>),
                                      <span class="st">'.Rdata'</span>))
        nsamp &lt;-<span class="st"> </span><span class="kw">nrow</span>(grp.dt)
        <span class="co">#Next, loop over chemicals and rbind the result.</span>
        allchems.dt &lt;-<span class="st"> </span>data.table::<span class="kw">rbindlist</span>(parallel::<span class="kw">parLapply</span>(<span class="dt">cl =</span> cluster,
                                                                 <span class="dt">X =</span> chemlist,
                                                                 <span class="dt">fun =</span> doforeachchem,
                                                                 <span class="dt">model =</span> model,
                                                                 <span class="dt">species =</span> <span class="st">'Human'</span>,
                                                                 <span class="dt">sigma.factor =</span> <span class="fl">0.3</span>,
                                                                 <span class="dt">css.method =</span> <span class="st">'analytic'</span>,
                                                                 <span class="dt">indiv.model.bio =</span> grp.dt,
                                                                 <span class="dt">ExpoCast.group =</span> grp,
                                                                 <span class="dt">poormetab =</span> poormetab,
                                                                 <span class="dt">fup.censor =</span> fup.censor,
                                                                 <span class="dt">nsamp =</span> nsamp,
                                                                 <span class="dt">Clint.vary =</span> <span class="ot">TRUE</span>))
        <span class="co">#Now, save the result. Put some metadata in the filename,</span>
        <span class="co">#like the group, the method used to generate this population,</span>
        <span class="co">#and the values of poormetab and fup.censor.</span>
        <span class="co">#Also put which HTTK model was used.</span>
        <span class="kw">saveRDS</span>(<span class="dt">object =</span> allchems.dt,
                <span class="dt">file =</span> <span class="kw">paste0</span>(<span class="st">'data/'</span>,
                              <span class="kw">paste</span>(<span class="st">'allchems'</span>, grp, popmethod,
                                    <span class="st">'poormetab'</span>, poormetab,
                                    <span class="st">'fup.censor'</span>, fup.censor,
                                    model, 
                                    <span class="st">&quot;FuptoFub&quot;</span>, <span class="dt">sep=</span><span class="st">'_'</span>),
                              <span class="st">'.Rdata'</span>))
        }
      }
    }
parallel::<span class="kw">stopCluster</span>(cluster)</code></pre></div>
<p>There – now we have Css and total clearance percentile data for each chemical, in each of the subpopulations of interest.</p>
<p>We also would like to evaluate Css and total clearance for a “virtual population” generated using independent Monte Carlo, for comparison purposes. First, we need to generate the independent-MC parameters.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">indep_gen &lt;-<span class="st"> </span>function(<span class="dt">nsamp=</span><span class="dv">1000</span>, <span class="dt">sigma.factor=</span><span class="fl">0.3</span>){
  
  COmean &lt;-<span class="st"> </span>physiology.data[physiology.data$Parameter==<span class="st">'Cardiac Output'</span>,
                               <span class="st">'Human'</span>]
  indep.bio &lt;-<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">Qcardiacc=</span>truncnorm::<span class="kw">rtruncnorm</span>(<span class="dt">n=</span>nsamp,
                                                          <span class="dt">mean=</span>COmean,
                                                          <span class="dt">sd=</span>sigma.factor*COmean,
                                                          <span class="dt">a=</span><span class="dv">0</span>)/<span class="dv">1000</span>*<span class="dv">60</span>)
  indep.bio[, BW:<span class="er">=</span>truncnorm::<span class="kw">rtruncnorm</span>(<span class="dt">n=</span>nsamp,
                                        <span class="dt">mean=</span>physiology.data[physiology.data$Parameter==<span class="st">'Average BW'</span>,
                                                                <span class="st">'Human'</span>],
                                        <span class="dt">sd=</span>sigma.factor*physiology.data[physiology.data$Parameter==<span class="st">'Average BW'</span>,
                                                                           <span class="st">'Human'</span>],
                                        <span class="dt">a=</span><span class="dv">0</span>)]
  indep.bio[, plasma.vol:<span class="er">=</span>truncnorm::<span class="kw">rtruncnorm</span>(<span class="dt">n=</span>nsamp,
                                                <span class="dt">mean=</span>physiology.data[physiology.data$Parameter==<span class="st">'Plasma Volume'</span>,
                                                                        <span class="st">'Human'</span>],
                                                <span class="dt">sd=</span>sigma.factor*physiology.data[physiology.data$Parameter==<span class="st">'Plasma Volume'</span>,
                                                                                   <span class="st">'Human'</span>],
                                                <span class="dt">a=</span><span class="dv">0</span>)/<span class="dv">1000</span>] <span class="co">#convert mL/kg to L/kg</span>
  indep.bio[, hematocrit:<span class="er">=</span>truncnorm::<span class="kw">rtruncnorm</span>(<span class="dt">n=</span>nsamp,
                                                <span class="dt">mean=</span>physiology.data[physiology.data$Parameter==<span class="st">'Hematocrit'</span>,
                                                                        <span class="st">'Human'</span>],
                                                <span class="dt">sd=</span>sigma.factor*physiology.data[physiology.data$Parameter==<span class="st">'Hematocrit'</span>,
                                                                                   <span class="st">'Human'</span>],
                                                <span class="dt">a=</span><span class="dv">0</span>,
                                                <span class="dt">b=</span><span class="dv">1</span>)]
  indep.bio[, million.cells.per.gliver:<span class="er">=</span>truncnorm::<span class="kw">rtruncnorm</span>(<span class="dt">n=</span>nsamp,
                                                              <span class="dt">mean=</span><span class="dv">110</span>,
                                                              <span class="dt">sd=</span>sigma.factor*<span class="dv">110</span>,
                                                              <span class="dt">a=</span><span class="dv">0</span>)]
  
  all.tissues &lt;-<span class="st"> </span>tissue.data$Tissue[tissue.data$Tissue!=<span class="st">'red blood cells'</span>]
  for (tissue in all.tissues){
    vol.mean &lt;-<span class="st"> </span>tissue.data[tissue.data$Tissue==tissue,
                            <span class="st">'Human Vol (L/kg)'</span>]
    flow.mean &lt;-<span class="st"> </span>tissue.data[tissue.data$Tissue==tissue,
                             <span class="st">'Human Flow (mL/min/kg^(3/4))'</span>]/
<span class="st">      </span><span class="dv">1000</span>*<span class="dv">60</span>
    if (tissue==<span class="st">'liver'</span>){ <span class="co">#subtract gut flow from portal vein flow</span>
      <span class="co">#to get arterial flow</span>
      flow.mean &lt;-<span class="st"> </span>(tissue.data[tissue.data$Tissue==<span class="st">'liver'</span>,
                                <span class="st">'Human Flow (mL/min/kg^(3/4))'</span>] -
<span class="st">                      </span>tissue.data[tissue.data$Tissue==<span class="st">'gut'</span>,
                                  <span class="st">'Human Flow (mL/min/kg^(3/4))'</span>])/
<span class="st">        </span><span class="dv">1000</span>*<span class="dv">60</span>
      }

    indep.bio[, <span class="kw">paste0</span>(<span class="st">'V'</span>,
                       tissue,
                       <span class="st">'c'</span>):<span class="er">=</span>truncnorm::<span class="kw">rtruncnorm</span>(<span class="dt">n=</span>nsamp,
                                                   <span class="dt">mean=</span>vol.mean,
                                                   <span class="dt">sd=</span>sigma.factor*vol.mean,
                                                   <span class="dt">a=</span><span class="dv">0</span>)]
    indep.bio[, <span class="kw">paste0</span>(<span class="st">'Q'</span>,
                       tissue,
                       <span class="st">'f'</span>):<span class="er">=</span>truncnorm::<span class="kw">rtruncnorm</span>(<span class="dt">n=</span>nsamp,
                                                   <span class="dt">mean=</span>flow.mean,
                                                   <span class="dt">sd=</span>sigma.factor*flow.mean,
                                                   <span class="dt">a=</span><span class="dv">0</span>)/Qcardiacc]
    }
  
  
  indep.bio[, Qtotal.liverc:<span class="er">=</span>(Qliverf+Qgutf)*Qcardiacc]
  indep.bio[, liver.density:<span class="er">=</span><span class="fl">1.05</span>]
  gfr.mean&lt;-physiology.data[physiology.data$Parameter==<span class="st">'GFR'</span>,
                               <span class="st">'Human'</span>]*<span class="dv">60</span>/<span class="dv">1000</span> <span class="co">#convert from ml/min/kg^(3/4) to L/hr/kg(3/4)</span>
  indep.bio[, Qgfrc:<span class="er">=</span>truncnorm::<span class="kw">rtruncnorm</span>(<span class="dt">n=</span>nsamp,
                                           <span class="dt">mean=</span>gfr.mean,
                                           <span class="dt">sd=</span>sigma.factor*gfr.mean,
                                           <span class="dt">a=</span><span class="dv">0</span>)]
  indep.bio[, 
            Vartc:<span class="er">=</span><span class="st"> </span>plasma.vol/
<span class="st">              </span>(<span class="dv">1</span>-hematocrit)/<span class="dv">2</span>] <span class="co">#L/kgBW</span>
  indep.bio[, 
            Vvenc:<span class="er">=</span><span class="st"> </span>plasma.vol/
<span class="st">              </span>(<span class="dv">1</span>-hematocrit)/<span class="dv">2</span>] <span class="co">#L/kgBW</span>
  <span class="kw">return</span>(indep.bio)
  }</code></pre></div>
<p>Next, we just call <code>doforeachchem()</code> on this independent-MC virtual population.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">model &lt;-<span class="st"> '3compartmentss'</span>
popmethod &lt;-<span class="st"> 'indepMC'</span>
TeachingDemos::<span class="kw">char2seed</span>(<span class="st">&quot;Caroline Ring&quot;</span>)
indep.bio &lt;-<span class="st"> </span><span class="kw">indep_gen</span>()
numcluster &lt;-<span class="st"> </span><span class="dv">40</span> <span class="co">#The number of processors to use in parallel</span>
<span class="co">#Note: This will depend on how many your machine has available!</span>
cluster &lt;-<span class="st"> </span>parallel::<span class="kw">makeCluster</span>(numcluster, <span class="dt">outfile=</span><span class="st">'indepMC_evalmodels_parallel_out.txt'</span>)
parallel::<span class="kw">clusterEvalQ</span>(<span class="dt">cl=</span>cluster,
                       {<span class="kw">library</span>(httk)})
<span class="co">#Set seeds on all workers for reproducibility</span>
parallel::<span class="kw">clusterSetRNGStream</span>(cluster, 
                              TeachingDemos::<span class="kw">char2seed</span>(<span class="st">&quot;Caroline Ring&quot;</span>))
for (poormetab in <span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>)){
  for (fup.censor in <span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>)){
allchems.dt &lt;-<span class="st"> </span>data.table::<span class="kw">rbindlist</span>(parallel::<span class="kw">parLapply</span>(<span class="dt">cl =</span> cluster,
                                                         <span class="dt">X =</span> chemlist,
                                                         <span class="dt">fun =</span> doforeachchem,
                                                         <span class="dt">model =</span> model,
                                                         <span class="dt">species =</span> <span class="st">'Human'</span>,
                                                         <span class="dt">sigma.factor =</span> <span class="fl">0.3</span>,
                                                         <span class="dt">css.method =</span> <span class="st">'analytic'</span>,
                                                         <span class="dt">indiv.model.bio =</span> indep.bio,
                                                         <span class="dt">ExpoCast.group =</span> <span class="st">'indepMC'</span>,
                                                         <span class="dt">poormetab =</span> poormetab,
                                                         <span class="dt">fup.censor =</span> fup.censor,
                                                         <span class="dt">nsamp =</span> <span class="dv">1000</span>,
                                                         <span class="dt">Clint.vary =</span> <span class="ot">TRUE</span>))
<span class="co">#Now, save the result. Put some metadata in the filename,</span>
<span class="co">#like the group, the method used to generate this population,</span>
<span class="co">#and the values of poormetab and fup.censor.</span>
<span class="co">#Also put which HTTK model was used.</span>
<span class="kw">saveRDS</span>(<span class="dt">object =</span> allchems.dt,
        <span class="dt">file =</span> <span class="kw">paste0</span>(<span class="st">'data/'</span>,
                      <span class="kw">paste</span>(<span class="st">'allchems'</span>, popmethod,
                            <span class="st">'poormetab'</span>, poormetab,
                            <span class="st">'fup.censor'</span>, fup.censor,
                            model, 
                            <span class="st">&quot;FuptoFub&quot;</span>, 
                            <span class="dt">sep=</span><span class="st">'_'</span>),
                      <span class="st">'.Rdata'</span>))
}
}

parallel::<span class="kw">stopCluster</span>(cluster)</code></pre></div>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>

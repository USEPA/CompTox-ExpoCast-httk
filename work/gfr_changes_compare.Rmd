---
title: "Differences from GFR changes"
author: "Caroline Ring"
date: "26 April 2022"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(data.table)
library(ggplot2)
library(patchwork)
```

```{r}
devtools::load_all(path = "../httk")
```

Path for saving output files (e.g. figures). This is currently set to a local folder on my machine that is *not* tracked by git or on Bitbucket. It doesn't need to be tracked, because the code in this document is sufficient to reproduce the output at any time.

```{r}
out_path <- "C:/Users/cring/OneDrive - Environmental Protection Agency (EPA)/httk/gfr_changes_output/"
```

# Introduction

The goal of this document is to investigate the effects of two changes that have been made:

1. Setting the "race coefficient" to 1 in the CKD-EPI equation that estimates GFR (glomerular filtration rate)
2. Adding estimated residual variability to the estimated GFR (estimated from summary statistics on the original data used to fit the CKD-EPI equation)

We will first investigate the effects of these changes on the simulated population distribution of GFR for a simulated non-Hispanic Black population. The "race coefficient" affects estimated GFR specifically for Black individuals, so we want to investigate the effects of removing it specifically for a non-Hispanic Black population.

The CKD-EPI equation "race coefficient" also applies only to adults (over age 18). For simulated individuals below age 18, a different (pediatric) equation is used to estimate GFR, one that does not have a "race coefficient". So we will restrict our investigation to a non-Hispanic Black *adult* population.

Second, we will investigate how these differences in simulated GFR distribution propagate to differences in steady-state plasma concentration distributions, in the same non-Hispanic Black adult population.

# GFR distributions for a simulated non-Hispanic Black adult population with and without the race coefficient

We want to get the GFR distributions for four combinations of conditions: including/excluding residual variability, and including/excluding the CKD-EPI "race coefficient." These are parameters for the HTTK-Pop functions, so we can set up a table of the various combinations and use it as input to HTTK-Pop.

Set up the table first.

```{r}
set.seed(42) #for reproducibility
par <- as.data.table(expand.grid(gfr_resid_var = c(FALSE, TRUE),
                                 ckd_epi_race_coeff = c(TRUE, FALSE)))
knitr::kable(par) #print in table format
```

To get the HTTK-Pop distributions for GFR under each of these four conditions, we call `httkpop_generate()`. This function returns a `data.table` of simulated individuals. Each row is one individual; each column is one demographic, physiological or other TK-relevant parameter. One of the columns is called `gfr_est`; this is the estimated GFR from the CKD-EPI equation. For the sake of efficiency, we'll keep only this column, discarding the other columns with demographic and physiology information.

To get a good sampling, we'll simulate 10000 individuals.

```{r}
set.seed(42)
DT_orig <- httkpop_generate(method = "d", #direct resampling
                                     nsamp = 10000, #5000 individuals
                                     agelim_years = c(18,79), #adults 18-79
                                     reths = "Non-Hispanic Black", #non-Hispanic Black individuals
                                     gfr_resid_var = TRUE,
                                     ckd_epi_race_coeff = FALSE)

#use data.table syntax to efficiently loop over rows of par
#recalculate GFR for the same poplation for each set of conditions -- this controls for random variation in other things (such as age, sex, etc.)
DT <- par[,
          .(gfr_est={
            tmp <- estimate_gfr(gfrtmp.dt = DT_orig,
                                 gfr_resid_var = gfr_resid_var,
                                 ckd_epi_race_coeff = ckd_epi_race_coeff)
            tmp[, gfr_est]
            }),
          by = .(gfr_resid_var,
                 ckd_epi_race_coeff)]
```

Here are the first few rows.

```{r}
head(DT)
```

Each row represents one simulated individual between ages 18-65, with ethnicity reported in NHANES as "Non-Hispanic Black."

For more informative plot labels, let's create labels that clearly explain the meaning of each combination of `gfr_resid_var` and `ckd_epi_race_coeff` values.

```{r}

DT[gfr_resid_var %in% FALSE & ckd_epi_race_coeff %in% FALSE,
   label:="No race coeff, no resid var"]
DT[gfr_resid_var %in% FALSE & ckd_epi_race_coeff %in% TRUE,
   label:="Race coeff, no resid var\n(old status quo)"]
DT[gfr_resid_var %in% TRUE & ckd_epi_race_coeff %in% FALSE,
   label:="No race coeff, resid var\n(new default)"]
DT[gfr_resid_var %in% TRUE & ckd_epi_race_coeff %in% TRUE,
   label:="Race coeff, resid var"]

DT[, label:=factor(label,
                   levels = c("Race coeff, no resid var\n(old status quo)",
                             "No race coeff, resid var\n(new default)",
                             "Race coeff, resid var",
                             "No race coeff, no resid var"))]
```

Now here are the first few rows of `DT`:

```{r}
head(DT)
```

Plot the distributions. Color-code them by the four different conditions on residual variability and CKD-EPI race coefficient.

```{r}
ggplot(DT) +geom_density(aes(x=gfr_est,
                             color = label,
                             fill = label),
                             alpha = 0.2,
                         size=1) +
  scale_color_brewer(palette = "Set2") +
    scale_fill_brewer(palette = "Set2") +
  theme_bw() +
  theme(legend.title = element_blank())

```

Let's try a six-panel layout giving pairwise comparisons.

```{r}
#set up named vector of colors to use for plotting
#same as in previous plot
colvect <- RColorBrewer::brewer.pal(n=4, name="Set2")
names(colvect) <- DT[, levels(label)]

#get pairwise combinations of labels
combinations <- combn(DT[, levels(label)],
                       m=2)

#loop over combinations and create one plot for each pair
#the result will be a list of ggplot2 objects
figlist <- apply(combinations,
                 2, 
                 function(x) {
                   ggplot(DT[label %in% x]) +
                     geom_density(aes(x=gfr_est,
                             color = label,
                             fill = label),
                             alpha = 0.2,
                         size=1) +
  scale_color_manual(values = colvect,
                     limits = force) +
  scale_fill_manual(values = colvect,
                     limits = force) +
  scale_x_continuous(limits = c(0,300)) +
  scale_y_continuous(limits = c(0,0.021)) +
  xlab("eGFR, mL/min/1.73 m2") +
  theme_bw() +
  theme(legend.title = element_blank(),
        legend.position = c(0.77,0.8),
        legend.background = element_blank())
                   },
  simplify = FALSE
  )
```

```{r}

#use `patchwork` R package to lay these out in a grid
patchwork::wrap_plots(figlist, ncol = 2) +
plot_annotation(tag_levels = "A",
title = "eGFR in a simulated Non-Hispanic Black adult population (n = 5000)") &
guides(fill = guide_legend(byrow = TRUE),
color = guide_legend(byrow = TRUE)) &
theme(legend.spacing.y = unit(0.5, "line"),
axis.text = element_text(size=12))

#save the grid as a PNG
png(paste0(out_path,
           "eGFR_dist.png"),
    height = 8, width = 10, units = "in", res = 300) #open PNG device

#output plot to PNG device by re-plotting it
patchwork::wrap_plots(figlist, ncol = 2) +
plot_annotation(tag_levels = "A",
title = "eGFR in a simulated Non-Hispanic Black adult population (n = 5000)") &
guides(fill = guide_legend(byrow = TRUE),
color = guide_legend(byrow = TRUE)) &
theme(legend.spacing.y = unit(0.5, "line"),
axis.text = element_text(size=12))

dev.off() #close PNG device

#save the grid as a PDF
pdf(paste0(out_path,
           "eGFR_dist.pdf"),
    height = 8, width = 10) #open PDF device

#output plot to PDF device by re-plotting it

patchwork::wrap_plots(figlist, ncol = 2) +
plot_annotation(tag_levels = "A",
title = "eGFR in a simulated Non-Hispanic Black adult population (n = 5000)") &
guides(fill = guide_legend(byrow = TRUE),
color = guide_legend(byrow = TRUE)) &
theme(legend.spacing.y = unit(0.5, "line"),
axis.text = element_text(size=12))

dev.off() #close PDF device

```

From these plots, we can see some key comparisons.

In panel A (comparing the previous status quo to the new defaults for GFR estimation), we see that with the new defaults, the mode of the distribution has shifted lower (orange curve). This reflects the effect of removing the "race coefficient" -- eGFRs generally shift lower. But there is a longer, heavier upper tail; this reflects the effect of properly adding residual variability to the CKD-EPI estimates.

In panel B, we see the effect of residual variability alone, when the race coefficient is used. The purple curve (race coefficient used and residual variability added) has a longer, heavier upper tail. Interestingly, the lower tail is not very different.

In panel C, we see the effect of the change in the race coefficient alone, when no residual variability is added in either case. Without the race coefficient (pink curve), the mode shifts lower. but the overall width and tails of the curve stay the same.

In panel D, we see the effect of the change in race coefficient alone, when residual variability is added in both cases. Without the race coefficient (orange curve), the mode shifts lower. but the overall width and tails of the curve stay the same.

In panel E, we see the effect of the change in residual variability alone, when the race coefficient is not used in either case. Int4restingly, with residual variability added (orange curve), the mode seems to shift a little bit downward, and the upper tail becomes longer and heavier.

In panel F, for completeness, we compare the two conditions that were neither the previous status quo nor the new default: using both the race coefficient and residual variability, vs. not using either. Interestingly, the mode of these two distributions is very similar! Adding the residual variability seems to skew the dsitribution to have a lower mode and a heavier upper tail, even when the race coefficient is used.

This figure (and discussion) is complicated and is probably too much for the main text. It is more of a supplemental figure. 

For the main text, let's present only Panel A -- comparison of the previous status quo to the new default. Save the first panel in isolation.

```{r}
#save as PNG
ggsave(filename = paste0(out_path,
                         "eGFR_dist_main.png"),
       plot = figlist[[1]] + 
         #setting byrow = TRUE is the only way legend.spacing.y has any effect
         guides(fill = guide_legend(byrow = TRUE),
                color = guide_legend(byrow = TRUE)) + 
         theme(axis.text = element_text(size=12),
                           legend.text = element_text(size=12),
               legend.spacing.y = unit(12, "pt"),
               legend.key.size = unit(24, "pt")),
       width = 6,
       height = 4,
       units = "in",
       dpi = 300)

#save as PDF
ggsave(filename = paste0(out_path,
                         "eGFR_dist_main.pdf"),
       plot = figlist[[1]] + 
         #setting byrow = TRUE is the only way legend.spacing.y has any effect
         guides(fill = guide_legend(byrow = TRUE),
                color = guide_legend(byrow = TRUE)) + 
         theme(axis.text = element_text(size=12),
                           legend.text = element_text(size=12),
               legend.key.size = unit(24, "pt"),
               legend.spacing.y = unit(12, "pt")),
       width = 6,
       height = 4,
       units = "in")
```




## Lower "bump" in GFR?

What is that lower peak?

Here's eGFR as a histogram, zoomed in to show only eGFR <= 50.

```{r}
ggplot(DT[label %in% c("Race coeff, no resid var\n(previous status quo)", "No race coeff, resid var\n(new default)") &
            gfr_est <=50]) +
geom_histogram(aes(x=gfr_est,
color = label,
fill = label),
alpha = 0.2,
size=1, position = "identity") +
scale_color_manual(values = colvect,
limits = force) +
scale_fill_manual(values = colvect,
limits = force)
```

and puton a log10 scale:

```{r}
ggplot(DT[label %in% c("Race coeff, no resid var\n(previous status quo)", "No race coeff, resid var\n(new default)") &
            gfr_est <=50]) +
geom_histogram(aes(x=gfr_est,
color = label,
fill = label),
alpha = 0.2,
size=1, position = "identity") +
scale_color_manual(values = colvect,
limits = force) +
scale_fill_manual(values = colvect,
limits = force) +
  scale_x_log10() +
  annotation_logticks(sides = "b")
```

Does the bump come rfom the residual varibility or not?
```{r}
ggplot(DT) +
  geom_density(aes(x = gfr_est)) +
 facet_grid(rows = vars(ckd_epi_race_coeff),
             cols = vars(gfr_resid_var),
             labeller = "label_both") +
  ggtitle("CKD-EPI eGFR")
```




I think the "small bump" is just the nature of the CKD-EPI equation at serum creatinine levels higher than about 2. It's because of the asymptotic behavior of the CKD-EPI equation at high serum creatinine, plus the nature of the population distribution of high serum creatinine, plus the way the kernel density plotting works in ggplot. You get those few outliers with very high serum creatinine

Here is the serum creatinine distribution:

```{r}
ggplot(DT_orig) +
  geom_density(aes(x = serum_creat)) +
  ggtitle("Serum creatinine") +
  scale_x_log10()
```

There is a long/heavy right tail on these distributions, which when transformed by the CKD-EPI equation, winds up turning into a "bump" on the lower end of eGFR. Basically, the CKD-EPI equation compresses all of that probability density into a bump on the lower end. 

Zoom in on the lower end of eGFR:

```{r}
ggplot(DT_orig) +
  geom_point(aes(x = serum_creat, y = gfr_est, color = gender)) +
  coord_cartesian(ylim = c(0,50))
```

Notice that adding the residual variability smooths out those lower bumps a bit because it spreads out the estimated GFR values more smoothly across the lower range.


# Effect on Css

So we know how GFR changes, particularly for Black individuals.

How much does the change in GFR change Css results?

Let's run the Css calculations for a n = 5000 non-Hispanic Black adult population, for all the chemicals for which the 3-compartment steady state model can be parameterized. Then we can assess how much the changes in race coefficient and residual variability actually affect steady-state plasma concentration results.

Get the list of all chemicals for which the 3-comaprtment steady-state model can be parameterized.

```{r}
chemlist <- get_cheminfo(info = "CAS", model = "3compartmentss")
```

Now, loop over this list of chemicals. For each one, call `httk::calc_mc_css()`, using the specified population. Keep the 5th, 50th, and 95th quantiles of Css.

First, do this for the new default: no race coefficient, add residual variability.

Note that this is a big simulation job, and will likely take several minutes to run.

```{r, eval = FALSE}
set.seed(42)
system.time(
  suppressWarnings(
    css_list_new <- t(
      sapply(
        chemlist,
                      function(chem){
                      suppressWarnings(parameter.dt <-  create_mc_samples(chem.cas = chem,
                                                         samples = 1e4,
                                         httkpop.dt = DT_orig,
                                         suppress.messages = TRUE))
                       parameter.dt[,Css:= do.call(calc_analytic_css,
                            args=list(parameters=.SD,
                              model="3compartmentss",
                              suppress.messages=TRUE,
                              chem.cas=chem,
                              output.units="uM")
                            )]
                       out <- parameter.dt[, quantile(Css, c(0.05,0.5,0.95), na.rm = TRUE)]
                       out <- c(out, parameter.dt[, sum(is.na(Css))])
                       out
                      }
        )
      )
    )
  )


#save results
saveRDS(css_list_new,
        paste0(out_path,
               "css_list_new.Rds")
)
```

Now, repeat the simulations for the old status quo (using the race coefficient, not adding residual variability).

```{r, eval = FALSE}
set.seed(42)
DT_old <- copy(DT_orig)
DT_old[, gfr_est:=DT[label %in% "Race coeff, no resid var\n(old status quo)", gfr_est]]
system.time(
  suppressWarnings(
    css_list_old <- t(
      sapply(
        chemlist,
                      function(chem){
                      suppressWarnings(parameter.dt <-  create_mc_samples(chem.cas = chem,
                                                         samples = 1e4,
                                         httkpop.dt = DT_old,
                                         suppress.messages = TRUE))
                       parameter.dt[,Css:= do.call(calc_analytic_css,
                            args=list(parameters=.SD,
                              model="3compartmentss",
                              suppress.messages=TRUE,
                              chem.cas=chem,
                              output.units="uM")
                            )]
                       out <- parameter.dt[, quantile(Css, c(0.05,0.5,0.95), na.rm = TRUE)]
                       out <- c(out, parameter.dt[, sum(is.na(Css))])
                       out
                      }
        )
      )
    )
  )

#save as Rds file
saveRDS(css_list_old,
        paste0(out_path,
               "css_list_old.Rds")
)
```

If the simulations have already been run and saved, read in the results.

```{r}
css_list_new <- readRDS(paste0(out_path,
               "css_list_new.Rds"))

css_list_old <- readRDS(paste0(out_path,
               "css_list_old.Rds"))
```


Combine these two output matrices together into a single `data.table`, identifying which ones are the new default and which ones are the old status quo.
```{r}
css_list_new <- as.data.table(css_list_new)
css_list_old <- as.data.table(css_list_old)
setnames(css_list_new, names(css_list_new), c("P5", "P50", "P95", "numNA"))
setnames(css_list_old, names(css_list_old), c("P5", "P50", "P95", "numNA"))
css_list_new[, CASRN:=chemlist]
css_list_old[, CASRN:=chemlist]
css_list <- rbindlist(list("new"=css_list_new,
                           "old"=css_list_old),
                      idcol = "GFR")
```

Now, reshape the `data.table` into a longer format. Instead of having separate columns for the different Css percentiles, have one column identifying the percentile (P5, P50, or P95), and another column giving its value.

```{r}
css_melt <- melt(css_list,
                 id.vars = c("GFR", "CASRN"),
                 measure.vars = c("P5", "P50", "P95"),
                 variable.name = "Percentile")
```

Now, reshape again, such that we have one column of percentile values for the "new" (ne default) case, and another column of percentile values for the "old" (previous status quo) case. This shape will make it easier to make a plot that contrasts old and new.

```{r} 

css_cast <- dcast(css_melt,
                  CASRN + Percentile ~ GFR,
                  value.var = "value")
```

Sort chemicals by 95th percentile Css. Create a factor-type variable to encode this ordering of the CASRNs. This will allow us to plot the chemicals sorted from lowest to highest Css95 (otherwise, `ggplot2` would by default plot them in alphabetical sort order by CASRN).

```{r}
css_sort <- setorder(css_list_new, P95)
chem_sort <- css_sort[, CASRN]
css_melt[, CASRN_cat:=factor(CASRN,
                             levels = chem_sort)]
css_cast[, CASRN_cat:=factor(CASRN,
                             levels = chem_sort)]
```

Plot the percentiles for the "new default" case.

```{r}
ggplot(css_melt[GFR %in% "new"]) +
  geom_point(aes(x = CASRN_cat,
                 y = value,
                 color = Percentile)) +
  scale_color_brewer(palette="Set2") +
  scale_y_log10() + annotation_logticks(sides="l")

ggsave(paste0(out_path, "css_percentiles_new_default.png"))
```

Plot the percentiles for the "previous status quo" case.

```{r}
ggplot(css_melt[GFR %in% "old"]) +
  geom_point(aes(x = CASRN_cat,
                 y = value,
                 color = Percentile)) +
  scale_color_brewer(palette="Set2") +
  scale_y_log10() + annotation_logticks(sides="l")

ggsave(paste0(out_path, "css_percentiles_previous_status_quo.png"))
```


Now, compare the two cases. make one plot that shows the 5th percentile for the new case vs. the 5th percentile for the old case. Make another plot that shows the 50th percentile for the new case vs. the 50th percentile for the old case. Make a third plot that does the same for the 95th percentile for old and new cases. This is easily done using the `ggplot2::facet_wrap()` function.

```{r}
ggplot(css_cast) +
  geom_point(aes(x=old,
                 y = new,
                 color = Percentile)
             ) +
  geom_abline(aes(slope=1,
                  intercept=0)
              ) +
  scale_x_log10() +
  scale_y_log10() +
  annotation_logticks() +
  facet_wrap(facets = vars(Percentile),
             nrow = 3,
             scales = "free") +
  scale_color_brewer(palette = "Set2") +
  theme_bw() +
  theme(legend.position = "none") +
  geom_blank()

ggsave(paste0(out_path, "css_percentiles_old_vs_new.png"))
```



On a log scale, these look very similar.

Let's zoom in on the 95th perecentile, the most sensitive 5\% of the population:

```{r}
ggplot(css_cast[Percentile %in% "P95"]) +
  geom_point(aes(x=old,
                 y = new),
             color = "#8DA0CB"
             ) +
  geom_abline(aes(slope=1,
                  intercept=0)
              ) +
  scale_x_log10() +
  scale_y_log10() +
  annotation_logticks() +
  scale_color_brewer(palette = "Set2") +
  theme_bw() +
  theme(legend.position = "none") +
  geom_blank()
  
  ggsave(paste0(out_path, "css_old_vs_new_P95.png"))
   ggsave(paste0(out_path, "css_old_vs_new_P95.pdf"))
```

## Very low Css?

What is that one down in the lower left corner?

```{r}
css_cast[Percentile %in% "P95" & old < 1e-6]
```

What are these names?

```{r}
chem.physical_and_invitro.data[chem.physical_and_invitro.data$CAS %in% css_cast[Percentile %in% "P95" & old < 1e-6, CASRN], c("Compound", "CAS")]
```

Why are the percentiles zero?

```{r}
css_list[CASRN %in% c("129453-61-8", "103-24-2")]
```

What happens if we just run analytical Css for these CASRNs?

```{r}
calc_analytic_css(chem.cas = "103-24-2", suppress.messages = TRUE)
```

OK, small, but not zero.

What does `calc_mc_css()` do?

```{r}
calc_mc_css(chem.cas = "103-24-2", suppress.messages = TRUE, which.quantile = c(0.05, 0.25, 0.5, 0.75, 0.95))
```

OK, that is just not right. Something is very strange here.

What about the other one?

```{r}
calc_analytic_css(chem.cas = "129453-61-8", suppress.messages = TRUE)
```

Well, that's absolutely not small. What the heck?

What does `calc_mc_css()` do?

```{r}
calc_mc_css(chem.cas = "129453-61-8", suppress.messages = TRUE, which.quantile = c(0.05, 0.25, 0.5, 0.75, 0.95))
```

Hmmm, OK, that is funky. Something is plain old wrong.

### Checking parameters


```{r}
parameterize_steadystate(chem.cas = "103-24-2")
```

I notice that Clint is large (392600) and Funbound.plasma is small (1e-04).

```{r}
parameterize_steadystate(chem.cas = "129453-61-8")
```

Clint is zero but seems to have an non-zero distribution. Similarly, Funbound.plasma is 1e-04 but seems to have a different distirbution?

What does `chem.physical_and_invitro_data` say?

```{r}
tmp <- get_cheminfo(info = c("CAS", "Compound", "Clint", "Clint.pValue", "Funbound.plasma"))
tmp[tmp$CAS %in% c("103-24-2", "129453-61-8"), ]
```

OK -- curiouser and curiouser. So that is not the same Clint distribution that gets returned by `parameterize_steadystate()` for CAS 129453-61-8.

```{r}
parameterize_pbtk(chem.cas = "129453-61-8")
```




# Difference between new and old Css

What is the difference between new and old?

```{r}
css_cast[, ratio_new_old:=new/old]
css_cast[, ratio_old_new:=old/new]
```

```{r}
ggplot(css_cast) +
  geom_density(aes(x=ratio_new_old,
                   color = Percentile),
               size = 1) +
  geom_vline(aes(xintercept = 1)) +
  scale_color_brewer(palette = "Set2")

ggsave(paste0(out_path, "css_ratio_new_old.png"))
```

To the right of the vertical line, Css is higher, meaning that equivalent dose (bioactive conentration/Css) is lower, meaning that BER would be lower for the same exposure, meaning that potential risk is higher.

Can simplify that to just "If Css is higher, then potential risk is also higher, assuming the same in vitro bioactive concentration and the same exposure."

Note that for the purple curve -- the most-sensitive 5\% of the population -- most of the area under the curve lies to the right of the vertical line.

In fact, 1.0 is what percentile?

```{r}
css_cast[Percentile %in% "P95", ecdf(ratio_new_old)(1.0)]
```

Meaning that how many chemicals have new Css95 higher than old Css95?

```{r}
1 - css_cast[Percentile %in% "P95", ecdf(ratio_new_old)(1.0)]
```
Almost 74\% of chemicals have new Css95 higher than old Css95. 

But how much higher? And what would that mean in terms of change in equivalent dose?

Change in equivalent dose is the multiplicative inverse of change in Css, ebcause equivalent dose is (bioactive concentration)/(Css for 1 mg/kg/day).

So, we can plot it:

```{r}
ggplot(css_cast) +
  geom_density(aes(x=1/ratio_new_old,
                   color = Percentile),
               size = 1) +
  geom_vline(aes(xintercept = 1)) +
  scale_color_brewer(palette = "Set2") +
  xlab("Factor of change in equiv. dose")
```

I think it would be best to relabel the x-axis as percentage change in equivalent dose


```{r}
library(scales)

ggplot(css_cast) +
  geom_density(aes(x=(1/ratio_new_old) - 1,
                   color = Percentile),
               size = 1) +
  geom_vline(aes(xintercept = 0)) +
  scale_color_brewer(palette = "Set2",
                     name = "Css percentile") +
  xlab("Percent change in equiv. dose with new eGFR defaults") +
  scale_x_continuous(labels = scales::percent_format(accuracy = 1)) +
  theme_bw() +
  theme(legend.position = c(0.8,0.8),
        axis.text = element_text(size= 12),
        axis.title = element_text(size = 14),
        legend.text = element_text(size = 12),
        legend.title = element_text(size = 14))


ggsave(paste0(out_path, "change_in_equiv_dose.png"))
ggsave(paste0(out_path, "change_in_equiv_dose.pdf"))
```

What this is showing me is that, *in vitro* bioactivity and exposure levels being equal, the change in Css is going to reduce BERs by at maximum 30\%. There aren't very many chemicals where that reduction would make the difference between low risk and high risk. But, these results do show that the "race coefficient" in the way we calculate GFR could have resulted in mathematical bias in the way we estimate potential risk.

Paste together this figure and the "eGFR_main" figure into a two panel figure

```{r}
panelA <- figlist[[1]] + 
         #setting byrow = TRUE is the only way legend.spacing.y has any effect
         guides(fill = guide_legend(byrow = TRUE),
                color = guide_legend(byrow = TRUE)) + 
         theme(axis.text = element_text(size=12),
                           legend.text = element_text(size=12),
               axis.title = element_text(size = 14),
               legend.key.size = unit(24, "pt"),
               legend.spacing.y = unit(12, "pt"),
               legend.position = c(0.77,0.7))

css_cast[, AED_pct:=(1/ratio_new_old) - 1]
panelB <- ggplot(css_cast[Percentile %in% "P95"]) +
  geom_histogram(aes(x=AED_pct),
                binwidth = 0.005,
               size = 1,
               fill = "white",
               color = "black") +
  # geom_vline(aes(xintercept = 0)) +
  # scale_color_brewer(palette = "Set2",
  #                    name = "Css percentile") +
  xlab("Percent change in equiv. dose with new eGFR defaults") +
  ylab("Count of chemicals") +
  scale_x_continuous(labels = scales::percent_format(accuracy = 1)) +
  theme_bw() +
  theme(legend.position = c(0.2,0.6),
        axis.text = element_text(size= 12),
        axis.title = element_text(size = 14),
        legend.text = element_text(size = 12),
        legend.title = element_text(size = 14))

#use patchwork to paste together panels
patchwork::wrap_plots(list(panelA, panelB), ncol = 1, nrow = 2) +
plot_annotation(tag_levels = "A")

pdf(paste0(out_path,
           "eGFR_results_main.pdf"),
    height = 5, width = 7) #open PDF device
patchwork::wrap_plots(list(panelA, panelB), ncol = 1, nrow = 2) +
plot_annotation(tag_levels = "A")
dev.off()

png(paste0(out_path,
           "eGFR_results_main.png"),
    res = 300,
    height = 5, width = 7,
    units = "in") #open PNG device
patchwork::wrap_plots(list(panelA, panelB), ncol = 1, nrow = 2) +
plot_annotation(tag_levels = "A")
dev.off()

```


Or get the empriical CDF

```{r}
panelB2 <- ggplot(css_cast) +
  stat_ecdf(aes(x=(1/ratio_new_old) - 1,
                   color = Percentile),
               size = 1) +
  # geom_vline(aes(xintercept = 0)) +
  scale_color_brewer(palette = "Set2",
                     name = "Css percentile") +
  xlab("Percent change in equiv. dose with new eGFR defaults") +
  scale_x_continuous(labels = scales::percent_format(accuracy = 1)) +
  theme_bw() +
  theme(legend.position = c(0.2,0.6),
        axis.text = element_text(size= 12),
        axis.title = element_text(size = 14),
        legend.text = element_text(size = 12),
        legend.title = element_text(size = 14))

#use patchwork to paste together panels
patchwork::wrap_plots(list(panelA, panelB2), ncol = 1, nrow = 2) +
plot_annotation(tag_levels = "A")

pdf(paste0(out_path,
           "eGFR_results_main_ecdf.pdf"),
    height = 5, width = 7) #open PDF device
patchwork::wrap_plots(list(panelA, panelB2), ncol = 1, nrow = 2) +
plot_annotation(tag_levels = "A")
dev.off()

png(paste0(out_path,
           "eGFR_results_main_ecdf.png"),
    res = 300,
    height = 5, width = 7,
    units = "in") #open PNG device
patchwork::wrap_plots(list(panelA, panelB2), ncol = 1, nrow = 2) +
plot_annotation(tag_levels = "A")
dev.off()
```

# hepatic clearance

```{r}
tmp <- chem.physical_and_invitro.data[css_cast$CASRN, c("Human.Clint", "Human.Clint.pValue", "Human.Funbound.plasma")]
css_cast[, (names(tmp)):=lapply(names(tmp), function(x) tmp[[x]])]
css_cast[grepl(x = Human.Clint, pattern = ",", fixed = TRUE),
         Clint_char:=tstrsplit(Human.Clint, split = ",", fixed = TRUE, keep = 1)]
css_cast[, Clint:=as.numeric(Clint_char)]
css_cast[!grepl(x = Human.Clint, pattern = ",", fixed = TRUE),
         Clint:=as.numeric(Human.Clint)]
css_cast[, Clint_p_correct:=Clint]
css_cast[Human.Clint.pValue>=0.05, Clint_p_correct:=0]

css_cast[, AED_pct_pos:=AED_pct>0]

ggplot(css_cast[is.finite(AED_pct_pos)]) +
  geom_histogram(aes(x = Clint_p_correct)) +
  facet_grid(vars(AED_pct_pos),
             scales = "free_y") +
  scale_x_log10()

```

```{r}
css_cast[grepl(x = Human.Funbound.plasma, pattern = ",", fixed = TRUE),
         Fup_char:=tstrsplit(Human.Funbound.plasma, split = ",", fixed = TRUE, keep = 1)]
css_cast[, Fup:=as.numeric(Fup_char)]
css_cast[!grepl(x = Human.Funbound.plasma, pattern = ",", fixed = TRUE),
         Fup:=as.numeric(Human.Funbound.plasma)]

ggplot(css_cast[is.finite(AED_pct_pos)]) +
  geom_histogram(aes(x = Fup)) +
  facet_grid(vars(AED_pct_pos),
             scales = "free_y") +
  scale_x_log10()
```

```{r}
ggplot(css_cast) +
  geom_hex(aes(y = Clint_p_correct,
               x = AED_pct),
           binwidth = c(0.005, 1)) +
  scale_y_log10() +
  scale_fill_viridis_c(trans = "log10") +
  scale_x_continuous(labels = scales::percent_format(accuracy = 1)) +
  annotation_logticks(sides = "l") +
  facet_grid(vars(Percentile)) +
  NULL
```

```{r}
css_cast[, AED_pct_lt_15:=AED_pct<=-0.15]

css_cast[, AED_pct_lt_10:=AED_pct<=-0.10]
css_cast[AED_pct_lt_10 %in% TRUE, category:="AED% < -10%"]
css_cast[AED_pct_lt_10 %in% FALSE, category:="AED% >= 10%"]

ggplot(css_cast[is.finite(AED_pct_lt_10)]) + 
  geom_histogram(aes(x = Clint_p_correct)) +
  facet_wrap(vars(category), scales = "free_y", nrow = 2) +
  #scale_x_log10(oob = squish_infinite) +
  scale_x_log10() +
  annotation_logticks(sides = "b") +
  xlab("Clint") +
  theme_bw() +
  theme(strip.background = element_blank(),
        axis.title = element_text(size = 14),
        axis.text = element_text(size=12),
        strip.text = element_text(size = 14))

ggsave(paste0(out_path, "Clint_hist_by_AED_pct.pdf"),
       height = 7,
       width = 5)

ggsave(paste0(out_path, "Clint_hist_by_AED_pct.png"),
       height = 7,
       width = 5,
       units = "in")


```



<!-- # Beyond this is some more exploratory analysis -->

<!-- We see an increasingly bimodal distribution as the Css percentile increases. I'm guessing those are chemicals primarily cleared via urine, vs. primarily cleared via hepatic metabolism? Let's plot against CLint. -->

<!-- ```{r} -->
<!-- css_cast[, c("Clint", -->
<!--              "Funbound.plasma", -->
<!--              "Funbound.plasma.adjustment"):=suppressWarnings(parameterize_steadystate(chem.cas = unique(CASRN), -->
<!--                                                                                       suppress.messages = TRUE)[c("Clint", -->
<!--                                                                                         "Funbound.plasma", -->
<!--                                                                                         "Funbound.plasma.adjustment")]), -->
<!--                                                                                         by = CASRN] -->

<!-- css_cast[, Cl_hep:=suppressWarnings(calc_hep_clearance(chem.cas = unique(CASRN), -->
<!--                                                                         suppress.messages = TRUE)), -->
<!--          by = CASRN] -->
<!-- ``` -->

<!-- ```{r} -->
<!-- css_cast[, Percentile_label:=paste0(gsub(x = Percentile, -->
<!--                                          pattern = "P", -->
<!--                                          replacement = ""), -->
<!--                                     "th percentile Css")] -->

<!-- css_cast[, Percentile_label:=factor(Percentile_label, -->
<!--                                     levels = c("5th percentile Css", -->
<!--                                                "50th percentile Css", -->
<!--                                                "95th percentile Css"))] -->
<!-- ``` -->

<!-- ```{r} -->
<!-- css_cast[, Clint_plot:=Clint] -->
<!-- css_cast[Clint==0, Clint_plot:=1e-5] -->

<!-- css_cast[, Clhep_plot:=Cl_hep] -->
<!-- css_cast[Cl_hep==0, Clhep_plot:=1e-7] -->
<!-- ``` -->



<!-- ```{r} -->
<!-- ggplot(css_cast) + -->
<!--   geom_point(aes(x = Clint_plot, -->
<!--                  y=(1/ratio_new_old) - 1)) + -->
<!--   facet_wrap(vars(Percentile_label), -->
<!--              nrow = 3, -->
<!--              ncol = 1) + -->
<!--   ylab("Percent change in equiv. dose with new eGFR defaults") + -->
<!--   xlab("Clint, uL/min/10^6 hepatocytes") + -->
<!--   scale_x_log10() + -->
<!--   scale_y_continuous(labels = scales::percent_format(accuracy = 1)) + -->
<!--   annotation_logticks(sides = "b") + -->
<!--   theme_bw() + -->
<!--   theme(axis.text = element_text(size= 12), -->
<!--         axis.title = element_text(size = 14), -->
<!--         strip.background = element_blank(), -->
<!--         legend.position = "top") -->
<!-- ``` -->

<!-- OK, that's very interesting. Almost all of the lower mode (below -10% change) is coming from Clint = 0 chemicals. -->

<!-- Let's try a hex plot? -->

<!-- ```{r} -->
<!-- ggplot(css_cast) + -->
<!--   geom_hex(aes(x = Clint_plot, -->
<!--                  y=(1/ratio_new_old) - 1)) + -->
<!--   facet_wrap(vars(Percentile_label), -->
<!--              nrow = 2, -->
<!--              ncol = 2) + -->
<!--   scale_fill_viridis_c() + -->
<!--   ylab("Percent change in equiv. dose with new eGFR defaults") + -->
<!--   xlab("Clint, uL/min/10^6 hepatocytes") + -->
<!--   scale_x_log10(breaks = 10^c(-5, seq(-4,4, by = 2)), -->
<!--                 labels = c(0, paste0("1e", -->
<!--                 seq(-4,5, by = 2) -->
<!--                 ) -->
<!--                 ) -->
<!--                 )+ -->
<!--   scale_y_continuous(labels = scales::percent_format(accuracy = 1)) + -->
<!--   annotation_logticks(sides = "b") + -->
<!--   theme_bw() + -->
<!--   theme(axis.text = element_text(size= 12), -->
<!--         axis.title = element_text(size = 14), -->
<!--         strip.background = element_blank(), -->
<!--         legend.position = "top") -->

<!-- ggsave(paste0(out_path, -->
<!--               "hex_plot_css_changs_vs_Clint.png"), -->
<!--        height = 7, -->
<!--        width = 7, -->
<!--        units = "in") -->

<!-- ggsave(paste0(out_path, -->
<!--               "hex_plot_css_changs_vs_Clint.pdf"), -->
<!--        height = 7, width = 7, -->
<!--        units = "in") -->
<!-- ``` -->

<!-- Clearly, those chemicals where these changes to the CKD-EPI equation & residual variability would result in a lower equivalent dose are the chemicals that do not get cleared by the liver very fast, so the passive renal clearance is more important. -->

<!-- Now, why there are chemicals where Clint is 0 and where the CKD-EPI revisions do not reduce equivalent dose, or even increase it? -->

<!-- I suspect these are chemicals where the measured Clint of 0 actually has some uncertainty and may not be zero.  -->

<!-- ```{r} -->
<!-- tmp <- unique(css_cast[Clint==0, .(CASRN, Clint)]) -->
<!-- foo <- as.data.table(chem.physical_and_invitro.data) -->
<!-- footmp <- foo[tmp, on = c("CAS" = "CASRN")][, .(Compound, CAS, Clint, Human.Clint, Human.Clint.pValue, Human.Funbound.plasma)] -->
<!-- head(footmp) -->

<!-- ``` -->

<!-- Find the Clint upper bound by splitting the string for the ones with comma-separated distribution.s -->

<!-- ```{r} -->
<!-- footmp[grepl(x = Human.Clint, -->
<!--              pattern = ","), -->
<!--        Clint.ub := tstrsplit(Human.Clint, split = ",", keep = 3) ] -->
<!-- footmp[, Clint.ub:=as.numeric(Clint.ub)] -->
<!-- ``` -->

<!-- What are the range of those upper bounds? -->

<!-- ```{r} -->
<!-- footmp[, range(Clint.ub, na.rm = TRUE)] -->
<!-- ``` -->

<!-- ```{r} -->
<!-- ggplot(footmp) + geom_histogram(aes(x = Clint.ub)) + scale_x_log10() -->
<!-- ``` -->

<!-- Does that explain it? Shouldn't the effective population distribution of Clint center around the median anyway, though? And wouldn't the Css95 be on the low end of Clint for a given chemical, not the high end?  -->



